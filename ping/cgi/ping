#!/usr/bin/env perl

use strict;
use warnings;

use File::Basename qw(dirname);
use IO::File;
autoflush STDOUT 1;

use Plack::Runner;

BEGIN {
    # $ENV{DEBUG_LOCAL} = 1;
    $ENV{PLACK_ENV} = ( defined $ENV{HT_DEV} ) ? 'development' : 'production';
}

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors __FILE__;

use Time::HiRes qw(time);

# ----------------------------------------------------------------------
# enable strict, only under development
# ----------------------------------------------------------------------
BEGIN {
    if ( $ENV{'DLPS_DEV'} ) {
        require "strict.pm";
        strict::import();

        # Set the SDRINST and SDRLIB environment variables in auth
        # system absence.
        require Auth::Surrogate;
        Auth::Surrogate::authorize('/ping/cgi');
    }
}

# Permit created directories at 777 and created files at 666.
umask 0000;

# MDP specfic
use Debug::DUtils;
use MdpGlobals;
use Identifier;

use MdpConfig;
use Auth::Auth;
use Utils;
use Database;
use Session;

use Institutions;

use Plack::Request;
use Plack::Response;

use URI::Escape;

use Ping::Utils;
use JSON::XS;


{
    package App;
    
    sub new {
        my $class = shift;

        my $self = {};
        bless $self, $class;
        return $self;
    }
    
    sub get_app_name {
        my $self = shift;
        return "ping";
    }
    
}

my $app = sub {
    my $env = shift;
    my $request = Plack::Request->new($env);
    my $response;
    
    sub _body {
        # true, decodeURIComponent('$displayName'), decodeURIComponent('$affiliation'), "$auth_type", "LOGGED IN"
        my ( $callback, $logged_in, $displayName, $affiliation, $auth_type, $print_disabled, $msg, $idp_list, $expired ) = @_;
        $print_disabled = $print_disabled ? 'true' : 'false';
        $expired = $expired ? 'true' : 'false';
        my $idp_list_json = ref($idp_list) ? encode_json($idp_list) : 'null';
        $displayName = $displayName || '';
        $affiliation = $affiliation || '';

        my $is_cosign_active = $MdpGlobals::is_cosign_active ? 'true' : 'false';
        
        my $retval = <<JAVASCRIPT;
var HT = HT || {};
HT.login_status = {};
HT.login_status.logged_in = $logged_in;
HT.login_status.displayName = decodeURIComponent('$displayName');
HT.login_status.affiliation = decodeURIComponent('$affiliation');
HT.login_status.expired = $expired;
HT.login_status.authType = "$auth_type";
HT.login_status.message = "$msg";
HT.login_status.u = $print_disabled;
HT.login_status.idp_list = $idp_list_json;
HT.is_cosign_active = $is_cosign_active;
JAVASCRIPT
        
        if ( $callback ) {
            $retval .= "\n" . qq{$callback(HT.login_status);} . "\n";
        }
        
        $retval .= <<JAVASCRIPT;
HT.shibboleth_alert = function() {
    alert("Please quit your browser to log out of Shibboleth.");
    return false;
}

HT.get_pong_target = function(target) {
    return "https://$ENV{SERVER_NAME}/cgi/ping/pong?target=" + target;
}

HT.login_href = function() {
    if ( HT.login_status.logged_in ) {
        if ( HT.login_status.authType == 'shibboleth' ) {
            return "";
        } else {
            return "https://$ENV{SERVER_NAME}/cgi/logout?" + window.location.href;
        }
    }
    // not logged in
    var target_1 = encodeURIComponent("https://$ENV{SERVER_NAME}/cgi/ping/pong?target=");
    return "http://$ENV{SERVER_NAME}/cgi/wayf?target=" + target_1 + encodeURIComponent(window.location.href);
}

HT.login_link = function() {
    var href = HT.login_href();
    var link;
    if ( HT.login_status.logged_in ) {
        link = 'Hi ' + HT.login_status.displayName + '! ';
        link += '<a href="' + href + '"';
        if ( HT.login_status.authType == 'shibboleth' ) {
            link += ' onclick="return HT.shibboleth_alert();"';
        }
        link += ' id="loginLink">(logout)</a>';
    } else {
        link = '<a href="' + href + '">Login</a>';
    }
    
    return link;
}
JAVASCRIPT
        
    }
    
    my $C = new Context;
    $C->set_object('App', new App);
    
    my $callback = $request->param('callback') || qq{ping_handler};
    
    # configuration; do we need our own config?
    my $config = new MdpConfig(
                               Utils::get_uber_config_path('ping'),
                               $ENV{SDRROOT} . "/ping/lib/Config/global.conf",
                               $ENV{SDRROOT} . "/ping/lib/Config/local.conf"
                              );
    $C->set_object('MdpConfig', $config);

    # if REMOTE_USER is set, we're done
    if ( $$env{REMOTE_USER} ) {

        # Database connection to look up mdp.ht_institutions table
        my $db = new Database('ht_web');
        $C->set_object('Database', $db);

        my $cgi = new CGI;
        $C->set_object('CGI', $cgi);

        # Session
        my $ses = Session::start_session($C);
        $C->set_object('Session', $ses);

        my $info = Ping::Utils::identify_user($C, $env, $config);

        $response = Plack::Response->new(200);
        $response->content_type('text/javascript');
        if ( $$info{auth_type} && $$info{auth_type} eq 'shibboleth' && ! exists($request->cookies->{HT_AUTHTYPE}) ) {
            $response->cookies->{HT_AUTHTYPE} = { 
                'value' => 'shibboleth', 
                'path' => '/',
                'domain' => '.hathitrust.org'
            };
        }
        my $displayName = uri_escape($$info{displayName});
        my $affiliation = uri_escape($$info{affiliation});
        $response->body(_body($callback, 'true', $displayName, $affiliation, $$info{authType}, $$info{u}, "LOGGED IN", 0));
        return $response->finalize;
    }    

    # now need to hit the database
    $C->set_object('MdpConfig', $config);

    my $cgi = new CGI;
    $C->set_object('CGI', $cgi);

    # Database connection
    my $db = new Database('ht_web');
    $C->set_object('Database', $db);

    # get an Auth object to trigger cgi/shcgi redirection
    my $auth = new Auth::Auth($C);
    $C->set_object('Auth', $auth);

    # get the institutions
    my $idp_list = Institutions::get_idp_list($C);

    # don't create a session unless absolutely necessary
    my $cookies = $request->cookies;
    if ( $$cookies{$config->get('cookie_name')} ) {
        # Session

        my $ses = Session::start_session($C);
        $C->set_object('Session', $ses);

        my $auth_type = $ses->get_persistent('authenticated_via');
        if ( ! $MdpGlobals::is_cosign_active || $auth_type && $auth_type eq Auth::Auth::SHIBBOLETH ) {
            # reinitialize Auth to trigger cgi/shcgi redirection / session expiration
            $auth->_initialize($C);            
        }

        # if this is https:// AND there's no REMOTE_USER then
        # we're still not logged in
        if ( $$env{HTTPS} && $$env{HTTPS} eq 'on' ) {
            $response = Plack::Response->new(200);
            $response->content_type('text/javascript');
            $response->body(_body($callback, 'false', "", "", 'null', 0, "NOT LOGGED IN: SESSION BUT NO AUTH", $idp_list, $ses->get_persistent('logged_out', 0)));
            return $response->finalize;
        }
    }

    # decidedly not authenticated
    $response = Plack::Response->new(200);
    $response->content_type('text/javascript');
    $response->body(_body($callback, 'false', "", "", 'null', 0, "NOT LOGGED IN: NO AUTHENTICATED VIA", $idp_list, 0));
    return $response->finalize;
    
};

Plack::Runner->new->run($app);
