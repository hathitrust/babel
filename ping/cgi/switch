#!/usr/bin/env perl

use strict;
use warnings;

use Plack::Runner;

BEGIN {
    # $ENV{DEBUG_LOCAL} = 1;
    $ENV{PLACK_ENV} = ( defined $ENV{HT_DEV} ) ? 'development' : 'production';
}

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors __FILE__;

use Time::HiRes qw(time);

# ----------------------------------------------------------------------
# enable strict, only under development
# ----------------------------------------------------------------------
BEGIN {
    if ( $ENV{'DLPS_DEV'} ) {
        require "strict.pm";
        strict::import();

        # Set the SDRINST and SDRLIB environment variables in auth
        # system absence.
        require Auth::Surrogate;
        Auth::Surrogate::authorize('/ping/cgi');
    }
}

# Permit created directories at 777 and created files at 666.
umask 0000;

# MDP specfic
use Debug::DUtils;
use MdpGlobals;
use Identifier;

use MdpConfig;
use Auth::Auth;
use Auth::ACL;
use Utils;
use Database;
use Session;

use Plack::Request;
use Plack::Response;

use Ping::Utils;
use JSON::XS;

use URI::Escape;

use CGI::PSGI;

{
    package App;

    sub new {
        my $class = shift;

        my $self = {};
        bless $self, $class;
        return $self;
    }

    sub get_app_name {
        my $self = shift;
        return "ping";
    }

}

my $app = sub {
    my $env = shift;
    my $request = Plack::Request->new($env);
    my $response;

    unless ( $$env{REMOTE_USER} ) {
        # punt and run; not even worth doing
    }

    my $role = $request->param('role');
    my $action = $request->param('action');

    my $C = new Context;
    $C->set_object('App', new App);

    # configuration; do we need our own config?
    my $config = new MdpConfig(
                               Utils::get_uber_config_path('ping'),
                               $ENV{SDRROOT} . "/ping/lib/Config/global.conf",
                               $ENV{SDRROOT} . "/ping/lib/Config/local.conf"
                              );

    $C->set_object('MdpConfig', $config);

    my $cgi;
    my $other = { %$env };
    $$other{METHOD} = q{GET};
    $cgi = CGI::PSGI->new($other);
    $C->set_object('CGI', $cgi);

    # Database connection
    my $db = new Database('ht_web');
    $C->set_object('Database', $db);

    # get an Auth object to trigger cgi/shcgi redirection
    my $auth = new Auth::Auth($C);
    $C->set_object('Auth', $auth);

    # Session
    # by putting this here, we are saying that EVERYONE will get a session
    # even just by browsing www and catalog
    my $ses = Session::start_session($C);
    $C->set_object('Session', $ses);

    if ( $role ) {

        my $check = 0;
        if ( $role eq 'default' ) {
            $check = 1;
        } else {
            foreach my $config ( $auth->get_switchable_roles($C) ) {
                if ( $$config{role} eq $role ) {
                    $check = 1;
                    last;
                }
            }
        }

        if ( $request->param('debug') eq 'status' ) {
            $response = Plack::Response->new(200);
            $response->content_type('text/plain');
            my $value = $ses->get_persistent('activated_role');
            $response->body(qq{$$env{REMOTE_USER} switched role = $value});
        } else {

            if ( $action ne 'cancel' && $check ) {
                $ses->set_persistent('activated_role', $role);
            }

            $response = Plack::Response->new(302);
            my $info = Ping::Utils::identify_user( $C, $env );
            $response->cookies->{'HTstatus'} = Utils::build_cookie(
                'value'  => encode_json($info),
            );

            $response->redirect($request->param("referer"));
        }


    } else {
        # put up a list of options. :yay:
        my $html = Utils::read_file("../web/switch.html");

        my $roles_list = [];

        my $activated_role = $ses->get_persistent('activated_role') || 'default';
        my $check = 0;
        my $config;

        my @switchable_roles = $auth->get_switchable_roles($C);

        if ( scalar @switchable_roles ) {

            # set up the default state
            my $checked = ( $activated_role eq 'default' ) ? 'checked="checked"' : '';
            push @$roles_list, <<DIV;
<div class="control">
    <input type="radio" name="role" value="default" id="role--default" $checked />
    <label class="radio" for="role--default">Member</label>
    <div class="control--help" style="marign-left: 0.25rem; font-size: 90%">
        <p style="margin-bottom: 1rem">
            Read and download public domain and open access books.
        </p>
    </div>
</div>
DIV

            foreach my $config_ ( $auth->get_switchable_roles($C) ) {
                $checked = ( $activated_role eq $$config_{role} ) ? 'checked="checked"' : '';
                my $snippet = Utils::read_file("../web/_switch_$$config_{role}.html");
                $$snippet =~ s,data-checked,$checked,;

                push @$roles_list, $$snippet;
            }

        }

        my $roles_list_html = join("\n", @$roles_list);
        $$html =~ s,\<\!\-\- ROLES_LIST \-\-\>,$roles_list_html,;

        my $referer = $request->param('target') || $request->referer;
        $$html =~ s,%REFERER%,$referer,;

        if ( $request->param('debug') ) {
            $$html =~ s,\<\!\-\- DEBUG_FLAG \-\-\>,<input type="hidden" name="debug" value="ssdproxy" />,;
        }

        # $ses->set_persistent('activated_redirect', $request->referer);

        $response = Plack::Response->new(200);
        $response->content_type('text/html');
        $response->body(Encode::encode('UTF-8', $$html));

    }


    $ses->close();


    return $response->finalize;
};

Plack::Runner->new->run($app);
