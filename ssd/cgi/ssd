#!/usr/bin/env perl

use strict;
umask 0000;

BEGIN {
    ## $ENV{DEBUG_LOCAL} = 1;
    ## use lib "$ENV{SDRROOT}/pt/lib"; # (to find PTGlobals when using DEBUG_LOCAL)
}

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

# ----------------------------------------------------------------------
# Performance measurement
# ----------------------------------------------------------------------
BEGIN {
    ( $main::realSTART ) = time;
}

BEGIN {
    if ( $ENV{'HT_DEV'} ) {
        # Set the AUTHZD_COLL environment variable in auth system absence.
        require Auth::Surrogate;
        Auth::Surrogate::authorize('/ssd/cgi');
    }
}


# ----------------------------------------------------------------------
# Libraries
# ----------------------------------------------------------------------
# ---------- Perl standard libs -----------
use CGI;

# Magic
use Attribute::Handlers;

# ----------  MDP specfic ----------
use MdpGlobals;
use Utils;
use Debug::DUtils;
use PI;
use View;
use Identifier;
use Auth::Logging;

use PTGlobals;

use PT::MdpItem;
use PT::PageTurnerUtils;
use PT::Prolog;

$::VERSION = 1.1200;

# ---------------------------------------------------------------------
#
#                           M A I N
#
# ---------------------------------------------------------------------

my $prolog = new PT::Prolog;

$prolog->Run(\&ValidityChecks, 'ssd');

my $C = $prolog->GetContext();
my $cgi = $C->get_object('CGI');
my $ses = $C->get_object('Session');
my $mdpItem = $C->get_object('MdpItem');

my $id = $cgi->param( 'id' );

# Save the current URL in the session so that later we can build a
# "back" link
PT::PageTurnerUtils::SetLastPageTurnerLinkFromSession( $cgi, $ses );

# Set valid orientation and page sequence values
$mdpItem->SetCurrentRequestInfo($C, \%PTGlobals::gValidRotationValues);

# As of Fri Aug 5 12:35:38 2011, To be considered for SSD
# determination the user's authentication credentials must assert SSD
# status. Generally, users arrive here by (1) following the CSS hidden
# link in pt or (2) by a proposed special SSD accessible catalog. They
# are responsible for being authenticated when they arrive here if
# they want access.  They are not forced to login.

if ( $C->get_object('Access::Rights')->assert_final_access_status($C, $id) eq 'allow' ) {
    # We reached this point because
    # (1) authed SSD user of ic on US soil or of pd where pd for non-US affiliates does not include pdus
    # or
    # (2) authed normal user of OP ic on US soil @OPB
    # or
    # (3) authed normal user of pd where pd for non-US affiliates does not include pdus
    # or
    # (4) any unauthed user of pd where pdus access must be on US soil

    # As of Fri Mar 18 14:32:00 2011, JPW authorized ssd cgi to
    # provide access to full book OCR for (3) in addition to
    # (1). Others get a page at a time OCR navigation.

    my $pd_pdus_world_cc = $C->get_object('Access::Rights')->public_domain_world_creative_commons($C, $id);

    my $auth = $C->get_object('Auth');
    my $ht_authenticated = $auth->affiliation_is_hathitrust($C);
    my $ssd_authenticated = $auth->get_eduPersonEntitlement_print_disabled($C);

    my $allow_full_ocr =
      (
       $ssd_authenticated
       ||
       ($ht_authenticated && $pd_pdus_world_cc)
      );

    # Log ic access to the HTTP header
    if ( Auth::Logging::log_incopyright_access($C, $id) ) {
        Auth::ACL::a_Increment_accesscount();
    }

    # Limited, page at a time OCR navigation is handled here by the
    # OcrHandler() and the CURRENT_PAGE_OCR PI handler.  Access to
    # Full OCR will be generated by the OCR_DATA PI handler.
    #
    if ($allow_full_ocr) {
        $mdpItem->OcrHandler($C);
        # OCR_DATA will test this downstream.
        $ses->set_transient_subkey('full_ocr', $id, 'allowed');
    }
    else {
        $mdpItem->OcrHandler($C);
    }
}

# ----------------------------------------------------------------------
# get XML template and process its PIs
# ----------------------------------------------------------------------

my $vw = new View($C);

my $act = $C->get_object('Action');

$vw->execute_view($C, $act);
$vw->output($C);

$C->dispose();

exit 0;

# ---------------------------------------------------------------------
#
#                       end of M A I N
#
# ---------------------------------------------------------------------

# ----------------------------------------------------------------------
# NAME         :
# PURPOSE      :
# CALLS        :
# INPUT        :
# RETURNS      :
# GLOBALS      :
# SIDE-EFFECTS :
# NOTES        :
# ----------------------------------------------------------------------
sub ValidityChecks
{
    my ( $cgi ) = @_;

    my $rc = PT::Prolog::ST_EMPTY;

    my $id = $cgi->param('id');

    # There must be a valid id of an item to view
    Utils::silent_ASSERT(Identifier::validate_mbooks_id($cgi),
                              qq{Invalid document id provided.});

    # lose any image map params
    $cgi->delete( 'x' );
    $cgi->delete( 'y' );
    $cgi->delete( 'orient' );

    my $seq = $cgi->param( 'seq' );
    if ( ! $seq  )
    {
        $rc |= PT::Prolog::ST_SEQ_NOT_SUPPLIED;
	$cgi->param( 'seq', $PTGlobals::gDefaultSeq );
    }

    if( $cgi->param ( 'page' ) ne 'ssd' )
    {
    	$cgi->delete( 'page' );
	$cgi->param( 'page', 'ssd');
    }

    $cgi->param( 'view', 'text' );

    return $rc;
}

