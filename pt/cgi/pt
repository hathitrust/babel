#!/usr/bin/env perl


# Copyright 2006, The Regents of The University of Michigan, All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use strict;
umask 0000;

# ----------------------------------------------------------------------
# Performance measurement
# ----------------------------------------------------------------------
BEGIN {
    ( $main::realSTART ) = time;
    ## $ENV{DEBUG_LOCAL} = 1;
    ## $ENV{TEST_BLACKLIST} = 1;
    # $ENV{REMOTE_ADDR} = '8.8.8.8';
    # $ENV{SDRINST} = '';
}


# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

# ----------------------------------------------------------------------
# enable strict, only under development
# ----------------------------------------------------------------------
BEGIN {
    # Set the SDRINST and SDRLIB environment variables in auth
    # system absence.
    require Auth::Surrogate;
    Auth::Surrogate::authorize('/pt/cgi');
}

# ----------------------------------------------------------------------
# Libraries
# ----------------------------------------------------------------------
# Perl standard libs
use CGI;
use JSON::XS;

# Magic
use Attribute::Handlers;

# MDP specfic
use Utils;
use Debug::DUtils;
use PI;
use View;
use Identifier;
use MdpGlobals;
use SLIP_Utils::Common;
use Auth::Logging;

# ----------------------------------------------------------------------
# define global namespaces
# ----------------------------------------------------------------------
use PTGlobals;

use PT::MdpItem;
use PT::Prolog;

$::VERSION = 1.1200;

# ---------------------------------------------------------------------
#
#                           MOBILE DETECTION
#
# ---------------------------------------------------------------------

{
    unless ( $ENV{QUERY_STRING} =~ m,skin=, || $ENV{TERM} ) {
        require HTTP::BrowserDetect;
        my $browser = HTTP::BrowserDetect->new();
        if ( 0 && ( $browser->mobile() || $browser->tablet() ) ) {
            # redirect out of here
            my $url = $ENV{REQUEST_URI};
            my $join = ";";
            if ( $url =~ m,&, ) {
                $join = '&';
            }
            print CGI::redirect(qq{${url}${join}skin=mobile});
            exit;
        }
    }
}

# ---------------------------------------------------------------------
#
#                           M A I N
#
# ---------------------------------------------------------------------

my $prolog = new PT::Prolog;

$prolog->Run(\&ValidityChecks, 'pt');

my $C = $prolog->GetContext();
my $gMdpItem = $C->get_object('MdpItem');

# Order matters. Any information specific to this request (page,
# possibly new handler, etc.) is done after initialization
$gMdpItem->SetCurrentRequestInfo($C, \%PTGlobals::gValidRotationValues);

my $config = $C->get_object('MdpConfig');
my $run_config = SLIP_Utils::Common::merge_run_config('pt', $config);
# Stomp $config in Context object
$C->set_object('MdpConfig', $run_config);

# Order matters, Save the current URL in the session so that later we
# can build a "back" link
my $gCgi = $C->get_object('CGI');
my $gDso = $C->get_object('Session');
PT::PageTurnerUtils::SetLastPageTurnerLinkFromSession( $gCgi, $gDso );

my $gId = $gCgi->param('id');

Auth::Logging::log_access($C, 'pt');
unless ( $C->get_object('Access::Rights')->assert_final_access_status($C, $gId) eq 'allow' ) {
    # Auth::Logging::log_failed_access($C, $gId, 'pt');
    if ( $C->get_object('Access::Rights')->suppressed($C, $gId ) ) {
        View::P_output_data_HTTP($C, undef, undef, 404);
        exit;
    }
}
else {
    # Security logging
    if ( Auth::Logging::log_incopyright_access($C, $gId) ) {
        Auth::ACL::a_Increment_accesscount($gId);
        # Auth::Logging::log_successful_access($C, $gId, 'pt');
    }

    if ( $gCgi->param('a') ) {
        View::P_output_data_HTTP($C, undef, undef, 204);
        exit;
    }

    # set up text, image or pdf handlers for this request
    $gMdpItem->DetermineAndSetContentHandler();

    # There will only be a "requested rotation" value if the user
    # clicked on a "rotate image" button
    if ( $gCgi->param( 'view' ) eq 'image' ) {
        # get displayable page image, if cached in web space), or
        # create and place in web space cache
        $gMdpItem->HandleImageContent();
    }
    elsif ( $gCgi->param( 'view' ) eq 'fpdf' || $gCgi->param( 'view' ) eq 'pdf'  ) {
        ### $gMdpItem->FullPdfHandler($C);
        require PT::PIFiller::Root;
        my $redirect_url = PT::PIFiller::Root::BuildImageServerPDFUrl($gCgi, $gCgi->param('view'));
        print $gCgi->redirect($redirect_url);
        exit;
    }
    elsif ( $gCgi->param( 'view' ) eq 'text' || $gCgi->param( 'view' ) eq 'plaintext' ) {
        # "text" view will eventually be handled by BookReader
        $gMdpItem->OcrHandler($C);

        # add line breaks to text with highlights and map special highlight chars
        PT::PageTurnerUtils::format_OCR_text( $gMdpItem->GetOcrTextRef(), 1 );
    }
}


# ----------------------------------------------------------------------
# get XML template and process its PIs
# ----------------------------------------------------------------------

# Pseudo-controller-like sequence follows
my $act = $C->get_object('Action');
$act->execute_action($C);

my $vw = new View($C);

$vw->execute_view($C, $act);
$vw->output($C);

$C->dispose();

exit 0;


# ---------------------------------------------------------------------
#
#                       end of M A I N
#
# ---------------------------------------------------------------------

# ----------------------------------------------------------------------
# NAME         :
# PURPOSE      :
# CALLS        :
# INPUT        :
# RETURNS      :
# GLOBALS      :
# SIDE-EFFECTS :
# NOTES        :
# ----------------------------------------------------------------------
sub ValidityChecks {
    my ( $cgi ) = @_;

    my $rc = PT::Prolog::ST_EMPTY;
    my $id = $cgi->param('id');

    # There must be a valid id of an item to view
    silent_ASSERT(Identifier::validate_mbooks_id($cgi), qq{Invalid document id provided.});

    # lose any image map params
    $cgi->delete( 'x' );
    $cgi->delete( 'y' );

    my $page = $cgi->param( 'page' );
    if (! grep(/^$page$/, @PTGlobals::gValidPageValues )) {
        $cgi->param( 'page', 'root' );
    }

    my $seq = $cgi->param( 'seq' );
    my $num = $cgi->param( 'num' );
    if (! ($seq || $num) )
    {
        # Support for starting at the title page
        $rc |= PT::Prolog::ST_SEQ_NOT_SUPPLIED;
    }

    # Set defaults to be overridden if processing for missing seq and
    # num is available downstream
    $seq =~ s,^[^0-9]*?(\d+).*?$,$1,;
    if ( ! $seq  ) {
        $cgi->param( 'seq', $PTGlobals::gDefaultSeq );
    }
    else {
        $cgi->param( 'seq', $seq );
    }

    my $view = $cgi->param( 'view' );
    my $size = $cgi->param( 'size' );
    my $orient = $cgi->param( 'orient' );

    unless ( $view ) {
        my $prefs = $cgi->cookie('HT.prefs');
        if ( $prefs ) {
            eval {
                $prefs = decode_json($prefs);
                $view = $$prefs{'pt'}{'view'};
                $cgi->param('view', $view);
            };
            if ( $@ ) {
                # ignore
                # $prefs = { pt => { view => $PTGlobals::gDefaultView } };
            }
        }
    }

    if ( ! $view ||
         ! grep(/^$view$/, (@PTGlobals::gViewTypes, @PTGlobals::gAuthdViewTypes))) {

        $rc |= PT::Prolog::ST_VIEW_NOT_SUPPLIED;

        if ( $cgi->param( 'ssd' ) ) {
            # 'ssd' URL param is deprecated
            $cgi->param( 'view', $PTGlobals::gDefaultSsdView );
        }
        else {
            $cgi->param( 'view', $PTGlobals::gDefaultView );
        }
    }

    if (! $size ||
        ! exists($PTGlobals::gSizes{$size})) {
        $cgi->param( 'size', $PTGlobals::gDefaultSize );
    }

    if ( $cgi->param('ui') eq 'embed' && ! $cgi->param('skin') ) {
        $cgi->param('skin', 'mobile');
    }

    ## assume defaults later down the road
    # if (! defined($orient) ||
    #     ! exists( $PTGlobals::gValidRotationValues{$orient})) {
    #     $cgi->param( 'orient', $PTGlobals::gDefaultOrientation );
    # }

    return $rc;
}

