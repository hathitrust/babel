#!/l/local/bin/perl


# Copyright 2006, The Regents of The University of Michigan, All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use strict;
umask 0000;

# ----------------------------------------------------------------------
# Performance measurement
# ----------------------------------------------------------------------
BEGIN {
    ( $main::realSTART ) = time;
    ## $ENV{DEBUG_LOCAL} = 1;
}


# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

# ----------------------------------------------------------------------
# enable strict, only under development
# ----------------------------------------------------------------------
BEGIN {
    # Set the SDRINST and SDRLIB environment variables in auth
    # system absence.
    require Auth::Surrogate;
    Auth::Surrogate::authorize('/pt/cgi');
}

# ----------------------------------------------------------------------
# Libraries
# ----------------------------------------------------------------------
# Perl standard libs
use CGI;

# Magic
use Attribute::Handlers;

# MDP specfic
use Utils;
use Debug::DUtils;
use PI;
use View;
use Identifier;
use MdpGlobals;

BEGIN {
    Debug::DUtils::setup_DebugScreen();
}

# ----------------------------------------------------------------------
# define global namespaces
# ----------------------------------------------------------------------
use PTGlobals;

use PT::MdpItem;
use Search::Utils;
use PT::Prolog;

$::VERSION = 1.1200;

# ---------------------------------------------------------------------
#
#                           M A I N
#
# ---------------------------------------------------------------------

my $prolog = new PT::Prolog;

$prolog->Run(\&ValidityChecks, 'pt');

my $C = $prolog->GetContext();
my $gMdpItem = $C->get_object('MdpItem');

# Order matters. Any information specific to this request (page,
# possibly new handler, etc.) is done after initialization
$gMdpItem->SetCurrentRequestInfo($C, \%PTGlobals::gValidRotationValues);

# Order matters, Save the current URL in the session so that later we
# can build a "back" link
my $gCgi = $C->get_object('CGI');
my $gDso = $C->get_object('Session');
PT::PageTurnerUtils::SetLastPageTurnerLinkFromSession( $gCgi, $gDso );

my $gId = $gCgi->param('id');
if ( $C->get_object('Access::Rights')->assert_final_access_status($C, $gId) eq 'allow' ) {
    # set up text, image or pdf handlers for this request
    $gMdpItem->DetermineAndSetContentHandler();
    
    # There will only be a "requested rotation" value if the user
    # clicked on a "rotate image" button
    if ( $gCgi->param( 'view' ) eq 'image' ) {
        # get displayable page image, if cached in web space), or
        # create and place in web space cache
        $gMdpItem->HandleImageContent();
    }
    elsif ( $gCgi->param( 'view' ) eq 'fpdf' || $gCgi->param( 'view' ) eq 'pdf'  ) {
        ### $gMdpItem->FullPdfHandler($C);
        require PT::PIFiller::Root;
        my $redirect_url = PT::PIFiller::Root::BuildImageServerPDFUrl($gCgi, $gCgi->param('view'));
        print $gCgi->redirect($redirect_url);
        exit;
    }
    elsif ( $gCgi->param( 'view' ) eq 'text' || $gCgi->param( 'view' ) eq 'plaintext' ) {
        # "text" view will eventually be handled by BookReader
        $gMdpItem->OcrHandler();
        
        my $q1 = $gCgi->param( 'q1' );
        if ( $q1 ) {
            my ( $numberOfFinalQs, $parsedQsCgi ) = Search::Utils::ParseSearchTerms($C, \$q1);
            Search::Utils::HighlightMultipleQs($C,
                                                     $parsedQsCgi,
                                                     $gMdpItem->GetOcrTextRef() );
        }
    }
}


# ----------------------------------------------------------------------
# get XML template and process its PIs
# ----------------------------------------------------------------------

# Pseudo-controller-like sequence follows
my $act = $C->get_object('Action');
$act->execute_action($C);

my $vw = new View($C);

$vw->execute_view($C, $act);
$vw->output($C);

$C->dispose();

exit 0;


# ---------------------------------------------------------------------
#
#                       end of M A I N
#
# ---------------------------------------------------------------------

# ----------------------------------------------------------------------
# NAME         :
# PURPOSE      :
# CALLS        :
# INPUT        :
# RETURNS      :
# GLOBALS      :
# SIDE-EFFECTS :
# NOTES        :
# ----------------------------------------------------------------------
sub ValidityChecks {
    my ( $cgi ) = @_;
    
    my $rc = PT::Prolog::ST_EMPTY;
    my $id = $cgi->param('id');
    
    # There must be a valid id of an item to view
    Utils::silent_ASSERT(Identifier::validate_mbooks_id($cgi),
                         qq{Invalid document id provided.});
    
    # lose any image map params
    $cgi->delete( 'x' );
    $cgi->delete( 'y' );
    
    my $page = $cgi->param( 'page' );
    if (! grep(/^$page$/, @PTGlobals::gValidPageValues )) {
        $cgi->param( 'page', 'root' );
    }
    
    my $seq = $cgi->param( 'seq' );
    my $num = $cgi->param( 'num' );
    if (! ($seq || $num) )
    {
        # Support for starting at the title page
        $rc |= PT::Prolog::ST_SEQ_NOT_SUPPLIED;
    }
    
    # Set defaults to be overridden if processing for missing seq and
    # num is available downstream
    $seq =~ s,^[^0-9]*?(\d+).*?$,$1,;
    if ( ! $seq  ) {
        $cgi->param( 'seq', $PTGlobals::gDefaultSeq );
    }
    else {
        $cgi->param( 'seq', $seq );
    }
    
    my $view = $cgi->param( 'view' );
    my $size = $cgi->param( 'size' );
    my $orient = $cgi->param( 'orient' );
    
    if ( ! $view ||
         ! grep(/^$view$/, (@PTGlobals::gViewTypes, @PTGlobals::gAuthdViewTypes))) {
        if ( $cgi->param( 'ssd' ) ) {
            $cgi->param( 'view', $PTGlobals::gDefaultSsdView );
        }
        else {
            $cgi->param( 'view', $PTGlobals::gDefaultView );
        }
    }
    
    if (! $size ||
        ! exists($PTGlobals::gSizes{$size})) {
        $cgi->param( 'size', $PTGlobals::gDefaultSize );
    }
    
    ## assume defaults later down the road
    # if (! defined($orient) ||
    #     ! exists( $PTGlobals::gValidRotationValues{$orient})) {
    #     $cgi->param( 'orient', $PTGlobals::gDefaultOrientation );
    # }
    
    return $rc;
}

