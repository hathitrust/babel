#!/usr/bin/env perl

=head1 NAME

stage-app - Stage a HT application on test.babel in preparation for testing.

=head1 SYNOPSIS

stage-app [options] [<app>]

=head1 OPTIONS

=over 8

=item B<-h>

Print a brief help message and exit.

=item B<-v>

Verbose status

=back

=head1 DESCRIPTION

B<stage-app> will attempt synchronize the local master branch of
test.babel (or as overridden by HTDE_APPROOT) for an existing
application <app> with origin/master after a fetch from origin at the
central repositoy including updating all submodules in preparation for
testing before deployment.

Note: B<stage-app> MUST be the only script that fetches origin for
/htapps/test.babel apps.

B<stage-app> -b<branch> will destroy the local repo for <app> and clone the local branch=<branch>
of the given developer's local repo,
e.g. /htapps/whoami.babel/<app> at beta-1,2,....babel for
an existing application <app>. This allows staging of topic branches
without the need to push to the branch to the central repo.

=cut

use strict;
use Getopt::Std;

use lib "${\($ENV{TOOLS_ROOT} || '/htapps/test.babel')}/mdp-lib/Utils";
use Vendors;
use File::Basename;
my $LOCATION = dirname(__FILE__);

use ToolLib;
use Date::Calc qw(Today_and_Now Delta_DHMS);

sub stage_app_usage {
    my $s = qq{Usage: stage-app [options] [<app> [<app>]+]
      For <app>:
        bring master branch up-to-date for testing under test.babel (default) or beta-{1,2,...}
        bring local topic branch up-to-date for testing under beta-{1,2,...} only

         When staging a single app at test.babel, prompts to display diff between
         staged commit and last deployed commit. Invokes \$EDITOR to display diff

         Options:
            -s <staging area>: test (default), beta-{1,2,...}, e.g. 'beta-2'
            -b <branch> at /htapps/whoami.babel/<app>. Note: <staging area> must be one of beta-{1,2,...}
            -A all apps. If -b <branch>, skip apps without a branch=<branch> 
            -d prompt to show diffs when staging multiple apps
                 (always prompts when staging a single app)
            -S <service>: babel (default), www, catalog
            -v verbose
            -h print help \n};
    return $s;
}

our ($opt_h, $opt_v, $opt_s, $opt_A, $opt_b, $opt_d, $opt_S);
my $ops = getopts('hvs:Ab:dS:');

my @valid_beta_stages = @ToolLib::valid_beta_stages;
my @all_valid_stages = @ToolLib::all_valid_stages;
my @all_valid_services = @ToolLib::all_valid_services;

my $help = $opt_h;
$ToolLib::VERBOSE = $opt_v;

if ($help) {
    print stage_app_usage();
    exit 0;
}

my $FORCE_DIFF = defined($opt_d);
my $BRANCH = $opt_b;
my $all = $opt_A;

my @APPS = __handle_APPS($all);

my $SERVICE = $opt_S;
if ($SERVICE) {
    if (! grep(/^$SERVICE$/, @all_valid_services)) {
        PrintN("$SERVICE is not a valid beta staging area\n");
        print stage_app_usage();
        exit 1;
    }
    $ToolLib::SERVICE = $SERVICE;
    PrintY("staging to $SERVICE\n");
}

my $STAGE = $opt_s;
if ($BRANCH) {
    if (! grep(/^$STAGE$/, @valid_beta_stages) && ! defined $ENV{DEBUG}) {
        PrintN("$STAGE is not a valid beta staging area\n");
        print stage_app_usage();
        exit 1;
    }
    my ($repo_root, $app_root) = get_HTDE_roots();
}
else {
    $STAGE = $opt_s || 'test';
    if (! grep(/^$STAGE$/, @all_valid_stages)) {
        PrintN("$STAGE is not a valid staging area\n");
        print stage_app_usage();
        exit 1;
    }
}

my $rc = 0;

if ($BRANCH) {
    foreach my $a (@APPS) {
        $rc |= stage_topic_branch($a, $BRANCH);
    }
}
else {
    $rc = stage_origin_master_branch(@APPS);
}

exit $rc;

#
# ------- Subroutines ------
#

# ---------------------------------------------------------------------

=item __handle_APPS

Description

=cut

# ---------------------------------------------------------------------
sub __handle_APPS {
    my $all = shift;

    my @all_apps = `cat $LOCATION/../lib/Config/app-list.txt`;
    chomp(@all_apps);

    my @apps;
    if ($all) {
        @apps = @all_apps;
    }
    else {
        @apps = @ARGV;
    }

    foreach my $a (@apps) {
        if (! grep(/^$a$/, @all_apps)) {
            PrintN("$a is not a valid app\n");
            my $apps = join(', ', @all_apps);
            print "Valid apps are: $apps\n";
            print stage_app_usage();
            exit 1;
        }
    }

    if (! scalar(@apps)) {
        PrintN("Missing <app> argument\n");
        print stage_app_usage();
        exit 1;
    }

    return @apps;
}

# ---------------------------------------------------------------------

=item list_submodule_dependencies

Description

=cut

# ---------------------------------------------------------------------
sub list_submodule_dependencies {
    my $app_dir = shift;

    if (-e "$app_dir/.gitmodules") {
        my @submodules = `cat "$app_dir/.gitmodules"`;
        @submodules = grep(/submodule/, @submodules);
        PrintM("Dependencies: \n\t");
        PrintM(join("\t", @submodules));
    }
    else {
        PrintY("No Dependencies\n");
    }
}

sub check_topic_branch {
    my ( $src_app_dir, $dest_app_dir ) = @_;
    if (-e "$dest_app_dir/.git/config") {
        my @lines = `cat "$dest_app_dir/.git/config"`;
        if ( grep(/url = $src_app_dir/, @lines) ) {
            return 1;
        }
    }
    return 0;
}

# ---------------------------------------------------------------------

=item stage_origin_master_branch

Description

=cut

# ---------------------------------------------------------------------
sub stage_origin_master_branch {
    my @apps = @_;

    my $rc = 0;
    my ($repo_root, $app_root) = get_HTDE_roots($STAGE);

    my $num_apps = scalar @apps;
    my $prompt_for_diff = $FORCE_DIFF || ($num_apps == 1);

    my $default_repo_root = $repo_root;

    foreach my $app (@apps) {
        my $fail_msg = qq{Failed to stage application ($app)\n};
        my $app_dir = app_dir($app_root,$app);

        if (! validate_existing_app($repo_root, $app_root, $app)) {
            PrintN($fail_msg);
            $rc |= 1;
            next;
        }

        PrintY(qq{\nStaging application ($app) at $app_dir\n});

        if (! (
               G_fetch_origin($app_dir)
               &&
               G_sync_local_master($app_dir)
               &&
               G_sync_local_deployment($app_dir)
               &&
               G_checkout_branch($app_dir, 'deployment')
               &&
               G_merge_master_branch($app_dir)
               &&
               G_update_submodules($app_dir)
              )
           ) {
            PrintN($fail_msg);
            $rc |= 1;
            next;
        }

        list_submodule_dependencies($app_dir);

        handle_staging_post_install_hook($app);

        PrintY("Begin validation checks ...\n");
        $rc |= system("$LOCATION/validate-app -s$STAGE $app");

        PrintY(qq{Staging succeeds\n}) unless ($rc);

        if ($STAGE eq 'test') {
            if ($prompt_for_diff) {
                if (query_yn("\nSee diff of staged commit vs. last deployment?", 'n')) {
                    if (! G_handle_diff($app, $app_dir)) {
                        PrintN(qq{Could not generate diff for application=$app at $app_dir\n});
                    }
                }
                else {
                    PrintY("OK\n");
                }
            }
        }
    }

    return $rc;
}

# ---------------------------------------------------------------------

=item stage_topic_branch

Description

=cut

# ---------------------------------------------------------------------
sub stage_topic_branch {
    my $app = shift;
    my $branch = shift;

    my ($src_repo_root, $src_app_root) = get_HTDE_roots();
    my $time = time;

    my $src_app_dir = "$src_app_root/$app";
    my $fail_msg = qq{Failed to stage app=$app from repo=$src_app_dir branch=$branch at $STAGE\n};

    if (! validate_existing_app($src_repo_root, $src_app_root, $app)) {
        PrintN($fail_msg);
        return 1;
    }

    my ($dest_repo_root, $dest_app_root) = get_HTDE_roots($STAGE);
    my $dest_app_dir = "$dest_app_root/$app";

    PrintY(qq{\nStaging via clone app=$app branch=$branch from $src_app_dir at $dest_app_root\n});

    if (check_topic_branch($src_app_dir, $dest_app_dir)) {
        if (! G_update_branch($dest_app_dir, $app, $branch)) {
            $rc |= 1;
        }
    } else {
        if (! query_yn("\nWARN: This will force rename of existing repo for app=$app to $app.$time under $dest_app_root. \n\tContinue?", 'y')) {
            return 0;
        }
        else {
            my $backup = "${dest_app_dir}.$time";
            print "Moving $dest_app_dir to $backup ... ";
            `mv $dest_app_dir $backup`;
            PrintY(qq{OK\n});
        }

        if (! G_clone($dest_app_root, $src_app_root, $app, $dest_app_dir, $branch)) {
            $rc |= 1;
        }
    }

    if (! G_init_submodules($dest_app_dir)) {
        $rc |= 1;
    }
    if (! G_update_submodules($dest_app_dir)) {
        $rc |= 1;
    }

    PrintY(qq{Staging via clone succeeds\n}) unless ($rc);

    handle_staging_post_install_hook($app);
    handle_staging_rdist_hook($app, $STAGE, $dest_app_root);
    emulate_rdist_bin_timestamp($app, $dest_app_root);

    return $rc;
}

# ---------------------------------------------------------------------

=item handle_staging_post_install_hook

Description

To avoid committing the results of npm run build (always the source of merge conflicts),
looks for $app/bin/build.sh and invokes that after staging the app.

Only reports build.sh output and whether it failed but otherwise is agnostic.

=cut

# ---------------------------------------------------------------------
sub handle_staging_post_install_hook {
    my $app = shift;

    my ($src_repo_root, $src_app_root) = get_HTDE_roots($STAGE);
    my $app_dir = app_dir($src_app_root,$app);

    my $build_sh = qq{$app_dir/bin/build.sh};

    if (! -e $build_sh) {
      PrintY(qq{No stage post-install script at $build_sh ... skip\n});
    }
    else {
      PrintY(qq{Now running stage post-install script=$build_sh...\n});
      print qx($build_sh);

      if ($?) {
        PrintN("ERROR: stage post-install script failure\n");
        return 0;
      }
      PrintY("Stage post-install succeeds.\n");
    }
    return 1;
}

__END__;
