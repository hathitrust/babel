****************************************************************
                        SLIP Maintenance
****************************************************************

Resetting a failed indexing run
===============================

Use the following sequence of commands:

$ ssh earlgrey-1
$ cd /htapps/babel/slip/index
$ ./control-j -r11 -kresetdriver
$ ./control-j -r11 -krestore  # errors back to indexing queue
$ ./control-j -r11 -kstart -D # enable driver to run

Then you can edit the SLIP crontab and advance the scheduled run of
$DRIVER to a few minutes into the future so cron will run it again. As
soon as driver gets scheduled, re-edit the start time back to, for
example, 09:20 as in:

20 9 * * *  eval $DRIVER


****************************************************************
                        SLIP Data Flows
****************************************************************

Resetting the queue timestamp
=============================
After the build on a given day, e.g. the 11th, items in j_rights with
timestamps <= the 10th have been indexed and the queue pointer is set
to the 10th. This means that the next time enqueuer-j runs, e.g. on
the 12th, items newer that the 10th, i.e. the 11th,  will be queued up.

So to go back and reindex, like after replacing the index with a
snapshot from the past, suppose the snapshot is of the build on the
3rd. After that build, all items through the 2nd were indexed.  So to
pick up items newer than the 2nd, the timestamp should be set to the
2nd.


SHADOW RIGHTS TABLE (ht_maintenance.slip_rights) CONSTRUCTION 
[script: rights-j]
==================================================================

Data Schema
-----------

mysql> describe ht_maintenance.slip_rights;
+-------------+-------------+------+-----+-------------------+-------+
| Field       | Type        | Null | Key | Default           | Extra |
+-------------+-------------+------+-----+-------------------+-------+
| nid         | varchar(32) | NO   | PRI |                   |       |
| attr        | tinyint(4)  | NO   | MUL | 0                 |       |
| reason      | tinyint(4)  | NO   |     | 0                 |       |
| source      | tinyint(4)  | NO   |     | 0                 |       |
| user        | varchar(32) | NO   |     |                   |       |
| time        | timestamp   | NO   |     | CURRENT_TIMESTAMP |       |
| sysid       | varchar(32) | NO   |     |                   |       |
| update_time | int(11)     | NO   | MUL | 0                 |       |
+-------------+-------------+------+-----+-------------------+-------+

The VuFind Solr index document has two fields to support ht_maintenance.slip_rights
updates of HathiTrust IDs (nid's: n]amespace + id).

Solr field: ht_id_display [stored, not indexed]:

a repeating field that contains the nid(s) of volumes associated with
the bib record together with the date each item was last updated and
an optional enumcron if the work is multi-volume. For example:

<arr name="ht_id_display">
  <str>mdp.39015066198014|20090701|v.1</str>
  <str>mdp.39015066198311|00000000|v.2</str>
  <str>mdp.39015066198170|00000000|v.3</str>
</arr>

Solr field: ht_id_update [not stored, indexed]:

the date when the bib record was last updated due to a change/addition
to the list in the ht_id_display field. One or more dates on the items
in the ht_id_didplay field will be the same as this field's value. In
the above example, ht_id_update would be 20090701

Querying
--------
rights-j does a VuFind Solr query based on timestamp=D, where D is 2
days earlier than the last run of rights-j.  The lag is to avoid
overlooking records than could have been added to the VuFind Solr
index after rights-j ran that day:

q=ht_id_update:[D TO *],fl=ht_id_display

These are bib records for added or updated (rights changed) volumes
but not for volumes where just the record-level metadata has changed.
These volumes correspond to ht_id_display items with dates equal or
newer that D. Just these volumes re-indexed to reflect their addition,
rights changes or reloaded status.

Processing
----------
rights-j gets timestamp=D from the j_vsolr_timestamp table which
records the newest update_time seen when rights-j last ran.

rights-j parses the item ids from the bib records that are >= to the
ht_it_update time and queries ht_repository.rights_current table for
the complete set of rights data for that id and REPLACES INTO
ht_maintenance.slip_rights with an update_time = the update time of
the item from ht_id_diaplay.


QUEUE (ht_maintenance.slip_queue) IDS FOR PROCESSING [script: enqueuer-j]
===========================================================

mysql> describe ht_maintenance.slip_queue;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| run         | smallint(3) | NO   | MUL | 0       |       |
| id          | varchar(32) | NO   | MUL |         |       |
| pid         | int(11)     | NO   | MUL | 0       |       |
| host        | varchar(32) | NO   | MUL |         |       |
| proc_status | smallint(1) | NO   | MUL | 0       |       |
+-------------+-------------+------+-----+---------+-------+

enqueuer-j script inserts records from ht_maintenance.slip_rights into
ht_maintenance.slip_queue where the update_time is newer than the
newest update_time seen on any record in ht_maintenance.slip_rights
the last time it ran. Processing means to copy from
ht_maintenance.slip_rights into ht_maintenance.slip_queue to be later
consumed by the index-j script.

The -R option builds ht_maintenance.slip_rights_temp, drops
ht_maintenance.slip_rights, renames renames
ht_maintenance.slip_rights_temp to ht_maintenance.slip_rights.

INDEXING (ht_maintenance.slip_indexed, ht_maintenance.slip_errors,
ht_maintenance.slip_timeouts) [script: index-j]
========================================================================

mysql> describe ht_maintenance.slip_indexed;
+------------+-------------+------+-----+---------------------+-------+
| Field      | Type        | Null | Key | Default             | Extra |
+------------+-------------+------+-----+---------------------+-------+
| run        | smallint(3) | NO   | PRI | 0                   |       |
| shard      | smallint(2) | NO   | PRI | 0                   |       |
| id         | varchar(32) | NO   | PRI |                     |       |
| time       | timestamp   | NO   |     | 0000-00-00 00:00:00 |       |
| indexed_ct | smallint(3) | NO   |     | 0                   |       |
+------------+-------------+------+-----+---------------------+-------+

One or more instances of index-j take id slices from
ht_maintenance.slip_queue, build a solr document, send the document to
a selected shard and record the facts for that id in
ht_maintenance.slip_indexed.

Indexing Errors
---------------
If there's an error (server gone, solr parse error, ocr error,
metadata error) the id is recorded in ht_maintenance.slip_errors for manual
resolution and re-queuing.

mysql> describe ht_maintenance.slip_errors;
+------------+-------------+------+-----+---------------------+-------+
| Field      | Type        | Null | Key | Default             | Extra |
+------------+-------------+------+-----+---------------------+-------+
| run        | smallint(3) | NO   | PRI | 0                   |       |
| shard      | smallint(2) | NO   |     | 0                   |       |
| id         | varchar(32) | NO   | PRI |                     |       |
| pid        | int(11)     | NO   |     | 0                   |       |
| host       | varchar(32) | NO   |     |                     |       |
| error_time | timestamp   | NO   |     | 0000-00-00 00:00:00 |       |
| reason     | tinyint(1)  | YES  |     | NULL                |       |
+------------+-------------+------+-----+---------------------+-------+

Indexing Timeouts
-----------------

mysql> describe ht_maintenance.slip_timeouts;
+--------------+-------------+------+-----+---------------------+-------+
| Field        | Type        | Null | Key | Default             | Extra |
+--------------+-------------+------+-----+---------------------+-------+
| run          | smallint(3) | NO   |     | 0                   |       |
| id           | varchar(32) | NO   |     |                     |       |
| shard        | smallint(2) | NO   |     | 0                   |       |
| pid          | int(11)     | NO   |     | 0                   |       |
| host         | varchar(32) | NO   |     |                     |       |
| timeout_time | timestamp   | NO   |     | 0000-00-00 00:00:00 |       |
+--------------+-------------+------+-----+---------------------+-------+


If there's an HTTP timeout, the document is assumed to be successfully
processed and is recorded in ht_maintenance.slip_indexed but also in
ht_maintenance.slip_timeouts in case it was not successfully
processed.  Timeouts are retried at the end of the indexing run using
the shard number from ht_maintenance.slip_indexed.


SYNCHRONIZING
=============

The model is

The data flow proceeds from

Vufind_Solr(slip_vufind_timestamp) {rebuild_rights-j}
   -> slip_rights(slip_rights_timestamp)
         -> slip_queue[run]
               -> slip_indexed[run] or slip_errors[run] {rebuild-j}
                     -> Solr

Assertion: If (1) - (3) are run in order everything should be synched.

(1) Make ht_maintenance.slip_rights match VuFind Solr.  Query VuFind
for ht_id_update:[0000000 TO *], build
ht_maintenance.slip_rights_temp, drop ht_maintenance.slip_rights,
rename ht_maintenance.slip_rights_temp to ht_maintenance.slip_rights:
    
       % rebuild_rights-j -r run -P one [-f <filename>] 
then
       % rebuild_rights-j -r run -P two [-n][-f <filename>] r

       NOTE: Phase=one: Read vSolr, write file
       NOTE: Phase=two: Read file, write slip_rights

       NOTE: coordinate Phase one with the VuFInd re-indexing job
       NOTE: Phase one: 6.5 hours 5.9M records 
             Phase two: 5.5 hours 10.6M IDs
                       ----
                       12.0 hours 


(2) Make j_indexed match the Solr shards.  Query Solr one shard at a
time, add ids to ht_maintenance.slip_indexed_temp.  De-dup
j_indexed_temp.  If an id is duped in ht_maintenance.slip_indexed_temp
it must be a duplicate in the Solr index because j_indexed_temp was
built from the Solr index: delete all but one of the duplicates from
the Solr index. Delete from ht_maintenance.slip_indexed for the given
run. Insert de-duped j_indexed_temp rows into j_indexed.

       % rebuild-j -r run

       NOTE: < 1 hour for 10.5M docs
       NOTE: Run this in parallel with rebuild_rights-j

(3) Queue ids in ht_maintenance.slip_rights missing from
ht_maintenance.slip_indexed. Ids that get queued up in this step must
be missing from Solr since ht_maintenance.slip_indexed equals the ids
in Solr. ***This cannot be done while indexing is in progress.***

       % sync-j -rN -m rightsNINindexed 
       NOTE: minutes for 10M docs


Exception
---------
The above does not guarantee that there are not ids in LSS Solr that
are not in HT Vufind Solr. These might be "vanished" barcodes.

Those can be checked for by:

     % sync-j -rN -m indexedNINrights
