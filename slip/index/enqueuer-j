#!/usr/bin/env perl

=head1 NAME

enqueuer-j

=head1 USAGE

% enqueuer-j -r run

=head1 DESCRIPTION

enqueuer-j reads the timestamp recorded in mdp.j_rights_timestamp when
it last did work. If there are ids in j_rights newer or _equal_ than
that time, it inserts those ids into the queue to be processed for the
given run.  Producers (index-j) read and dequeue from the queue.

The enqueuer-j runs independently of the other scripts, i.e if index-j
is disabled, enqueuer-j still runs.


=head1 OPTIONS

=over 8

=item -

see help

=back

=cut


use strict;
use warnings;
umask 0000;

BEGIN {
    ##$ENV{DEBUG_LOCAL} = 1;
}


# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;



# Perl
use Getopt::Std;

# App
use Utils;
use Utils::Time;
use Utils::GlobalSwitch;
use Debug::DUtils;

use Context;
use MdpConfig;
use Database;
use Semaphore;
use SharedQueue;
use Search::Site;

# Local
use SLIP_Utils::Log;
use SLIP_Utils::Load;
use SLIP_Utils::Common;
use Db;

my $INTERACTIVE = $ENV{TERM};

if ($INTERACTIVE) {
    if (Utils::GlobalSwitch::cron_jobs_disabled('slip', 'STOPSLIP')) {
        __output("Cannot optimize. STOPSLIP in place!!\n");
        exit 0;
    }
}
else {
    Utils::GlobalSwitch::Exit_If_cron_jobs_disabled('STOPSLIP');
}


# ---------------------------------------------------------------------

=item qu_get_usage

Description

=cut

# ---------------------------------------------------------------------
sub qu_get_usage {
    my $s;
    $s .= qq{Usage: enqueuer-j -r run [-n] [-d]};
    $s .= qq{ [-F filename]\n};

    return $s;
}

our ($opt_d, $opt_r, $opt_F, $opt_n);

my $ops = getopts('dr:F:n');

# Required
my $RUN = $opt_r;
if (! $opt_r) {
    my $s = qu_get_usage();
    my $rc = $SLIP_Utils::States::RC_BAD_ARGS;

    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

# Enqueue ids from a file
my $ID_FILENAME;
if (defined($opt_F)) {
    $ID_FILENAME = $opt_F;
}

my $CHECK = defined($opt_n);

if (defined($opt_d)) {
    $ENV{'DEBUG'} .= ',lsdb,idx,doc,me';
}

# Prevent replication errors: enqueue only to one mysqlserv
if (Search::Site::get_server_site_name() ne 'macc') {
    if (! $CHECK) {
        __output("Only runs from MACC unless check mode (-n)\n");
        exit 0;
    }
}

# Do not try to enqueue ids while I am running already
my $Lock_File = "/tmp/enqueuer-$RUN-lock.sem";
my $Semaphore = new Semaphore($Lock_File);
if (! $Semaphore) {
    __output("Could not get semaphore file: $Lock_File\n");
    exit 0;
}
END {
    $Semaphore->unlock()
        if ($Semaphore);
}

# Flush i/o
$| = 1;

my $C = new Context;

my $config = SLIP_Utils::Common::gen_run_config('slip', $RUN);
$C->set_object('MdpConfig', $config);

my $db;
eval {
    $db = new Database($config);
};
if ($@) {
    SLIP_Utils::Common::Log_database_connection_error($C, 'enqueuer-j', $@);
    exit $SLIP_Utils::States::RC_DATABASE_CONNECT;
}

$C->set_object('Database', $db);

my $DBH = $C->get_object('Database')->get_DBH();

eval {
    if (defined($ID_FILENAME)) {
        enqueue_from_FILE($C, $DBH, $RUN);
    }
    else {
        if (
            qu_enqueuer_enabled($C, $DBH, $RUN)
            ||
            $INTERACTIVE
           ) {
            enqueue_from_j_rights($C, $DBH, $RUN);
            enqueue_from_shared_queue($C, $DBH, $RUN);
        }
        else {
            my $s = qq{enqueuer-j not enabled\n};
            __output($s);
        }
    }   
};
if ($@) {
    my $rc = $SLIP_Utils::States::RC_CRITICAL_ERROR;
    my $s = qq{CRITICAL ERROR: $@\n};
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

exit 0;

#
# --------------------- S u b r o t i n e s   -------------------------
#




# ---------------------------------------------------------------------

=item __handle_queue_insert

Description

=cut

# ---------------------------------------------------------------------
sub __handle_queue_insert {
    my $C = shift;
    my $dbh = shift;
    my $run = shift;
    my $ref_to_arr_of_ids = shift;

    my $total_num_inserted = 0;
    
    while (1) {
        # Insert in blocks of 100
        my @queue_array = splice(@$ref_to_arr_of_ids, 0, 100);
        last
            if (scalar(@queue_array) <= 0);

        my $ref_to_arr_of_hashref = [];
        foreach my $id (@queue_array) {
            my $shard = Db::Select_item_id_shard($C, $dbh, $run, $id);
            push(@$ref_to_arr_of_hashref, {id => $id, shard => $shard});
        }

        my $num_inserted = Db::insert_queue_items($C, $dbh, $run, $ref_to_arr_of_hashref);
        $total_num_inserted += $num_inserted;
        my $s0 = qq{--> added $num_inserted items to queue, total now $total_num_inserted\n};
        __output($s0);
    }

    my $s1 = qq{added $total_num_inserted total items to queue\n};
    __output($s1);

    return $total_num_inserted;
}



# ---------------------------------------------------------------------

=item enqueue_from_FILE

Description

=cut

# ---------------------------------------------------------------------
sub enqueue_from_FILE {
    my ($C, $dbh, $run) = @_;

    my $ref_to_arr_of_ids = SLIP_Utils::Load::load_ids_from_file($C, $ID_FILENAME);
    my $num_loaded = scalar(@$ref_to_arr_of_ids);

    if ($num_loaded > 0) {
        my $s0 = qq{loaded $num_loaded items from file=$ID_FILENAME\n};
        __output($s0);
        __confirm("OK to proceed? [N] ");
        __handle_queue_insert($C, $dbh, $run, $ref_to_arr_of_ids);
    }
    else {
        my $s1 = qq{no items to add to queue\n};
        __output($s1);
    }
}

# ---------------------------------------------------------------------

=item enqueue_from_shared_queue

Description

=cut

# ---------------------------------------------------------------------
sub enqueue_from_shared_queue {
    my ($C, $dbh, $run) = @_;

    my $config = $C->get_object('MdpConfig');
    
    my $production_run = $config->get('run_allowed_to_access_shared_queue');
    if ($run ne $production_run) {
        __output(qq{skipping load from shared queue: run=$run is not the production run ($production_run)\n});
        return;  
    }

    my $daily_max = $config->get('shared_queue_daily_max_items');
    my $slice_size = min($config->get('shared_queue_slice_size'), $daily_max);
    
    my $shared_queue_size = SharedQueue::count_shared_queue_ids($C, $dbh);

    if ($CHECK) {
        my $s = ($shared_queue_size > 0)
          ? qq{would load daily max=$daily_max items from total=$shared_queue_size from shared queue}
            : qq{no items in shared queue to add to queue};

        __output(qq{$s\n});
        return;
    }
    
    my $num_items = 0;
    while (1) {
        my ($ok, $id_arr_ref) = SharedQueue::dequeue_item_ids($C, $dbh, $slice_size);

        if (! $ok) {
            my $s = qq{failed to dequeue items from shared queue after inserting $num_items};
            __output(qq{$s\n});
            qu_Log_misc($C, $run, $s);
            last;
        }

        last if (! scalar(@$id_arr_ref));
        
        my $num_inserted = __handle_queue_insert($C, $dbh, $run, $id_arr_ref);
        $num_items += $num_inserted;
        
        last if ($num_items >= $daily_max);
    }
    
    my $s = ($num_items > 0)
      ? qq{loaded $num_items items from shared queue where daily max=$daily_max}
        : qq{no items in shared queue to add to queue};

    __output(qq{$s\n});
    qu_Log_misc($C, $run, $s);
}


# ---------------------------------------------------------------------

=item enqueue_from_j_rights

Description

=cut

# ---------------------------------------------------------------------
sub enqueue_from_j_rights {
    my ($C, $dbh, $run) = @_;

    my $before_timestamp = Db::Select_j_rights_timestamp($C, $dbh, $run);
    my $would_be_queued = Db::count_insert_latest_into_queue($C, $dbh, $run);
    my $relation = ($before_timestamp eq $Db::vSOLR_ZERO_TIMESTAMP) ? '>=' : '>';
    my $out_msg = qq{count=$would_be_queued would be queued with timestamp $relation $before_timestamp\n};
 
    if ($CHECK) {
        __output($out_msg);
    }
    else {
        # Insert items into the queue and mark their status as "available"
        
        __output($out_msg);
        __confirm("OK to proceed? [N] ");

        # Get all items from the j_rights table with update_time newer
        # than the timestamp set when enqueuer-j last recorded
        # the MAX(update_time) and insert them into j_queue advancing the
        # timestamp j_rights_timestamp
        my $s0 = qq{Beginning insert into Primary queue. Please wait, this will take a while ...\n};
        __output($s0);
        my $num_inserted = Db::insert_latest_into_queue($C, $dbh, $run);
        my $after_timestamp = Db::Select_j_rights_timestamp($C, $dbh, $run);
        
        if ($num_inserted > 0) {
            my $s = qq{Primary add $num_inserted items to queue};
            __output(qq{$s\n});
            DEBUG('me', qq{DEBUG: $s});
            qu_Log_work($C, $run, $num_inserted, $before_timestamp, $after_timestamp);
        }
        else {
            my $s = qq{no Primary items to add to queue};
            __output(qq{$s\n});
            DEBUG('me', qq{DEBUG: $s});
            qu_Log_work($C, $run, 0, $before_timestamp, $after_timestamp);
        }
    }
}


# ---------------------------------------------------------------------

=item qu_enqueuer_enabled

Is enqueuer enabled?

=cut

# ---------------------------------------------------------------------
sub qu_enqueuer_enabled {
    my ($C, $dbh, $run) = @_;

    my $enquerer_enabled = Db::Select_enqueuer_enabled($C, $dbh, $run);

    return $enquerer_enabled;
}

# ---------------------------------------------------------------------

=item qu_Log_work

Description

=cut

# ---------------------------------------------------------------------
sub qu_Log_work {
    my ($C, $run, $num_inserted, $t_before, $t_after) = @_;

    my $f = '';
    if (defined($ID_FILENAME)) {
        $f = qq{from file=$ID_FILENAME};
    }

    my $s = qq{enqueuer-j: added $num_inserted $f items to queue before_timestamp=$t_before after_timestamp=$t_after at: } . Utils::Time::iso_Time();
    SLIP_Utils::Log::this_string($C, $s, 'indexer_logfile', '___RUN___', $run);
    SLIP_Utils::Log::this_string($C, $s, 'enqueuer_logfile', '___RUN___', $run);
}


# ---------------------------------------------------------------------

=item qu_Log_misc

Description

=cut

# ---------------------------------------------------------------------
sub qu_Log_misc {
    my ($C, $run, $s) = @_;

    my $s0 = qq{enqueuer-j: $s at: } . Utils::Time::iso_Time();
    SLIP_Utils::Log::this_string($C, $s0, 'indexer_logfile', '___RUN___', $run);
    SLIP_Utils::Log::this_string($C, $s0, 'enqueuer_logfile', '___RUN___', $run);
}



1;


=head1 AUTHOR

Phillip Farber, University of Michigan, pfarber@umich.edu

=head1 COPYRIGHT

Copyright 2008-11 ©, The Regents of The University of Michigan, All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
