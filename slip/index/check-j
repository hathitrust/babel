#!/usr/bin/env perl

=head1 NAME

check-j

=head1 USAGE

see usage

=head1 DESCRIPTION

Perform health checks on index. Check correct number of segments and
run Lucene CheckIndex on a given shard. driver-j will only enable
check-j whe all shards have finished optimizing to ensure enough
memory to run CheckIndex.

=head1 OPTIONS

=over 8

=item -

see help

=back

=cut

use strict;

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;


# Perl
use Getopt::Std;

# App
use Utils;
use Utils::Time;
use Utils::GlobalSwitch;
use Debug::DUtils;

use Context;
use MdpConfig;
use Database;
use Search::Constants;
use Semaphore;

# Local
use Db;
use Scheduler;
use SLIP_Utils::Common;
use SLIP_Utils::Solr;
use SLIP_Utils::Processes;
use SLIP_Utils::States;
use SLIP_Utils::Log;

Utils::GlobalSwitch::Exit_If_cron_jobs_disabled('slip');

# Flush i/o
$| = 1;

sub ck_get_usage {
    my $s .= qq{Usage: check-j -r run -R shard -On -C [-d][-n]
       where -C runs the (long-running) CheckIndex
             -O is number of segments to check for
             -n runs without calling check-shard or CheckIndex. NOTE: Sets done db flag.\n};
    return $s;
}

our ($opt_r, $opt_R, $opt_C, $opt_O, $opt_d, $opt_n);

my $ops = getopts('r:R:CdnO:');
use constant STOPSLIP_CSLEEP_WAIT => 60;  # 1 minute
use constant TOMCAT_MAX_TRIES => 10;
use constant TOMCAT_TRIES_WAIT => 30; # 0.5 minute

my $INTERACTIVE = $ENV{'TERM'};

my $NOOP = $opt_n; # optional
my $RUN = $opt_r; # Required
if (! $RUN) {
    my $s = qq{run (-r) parameter missing } . ck_get_usage();
    my $rc = $SLIP_Utils::States::RC_BAD_ARGS;
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

my $SHARD = $opt_R; # Required
if (! defined($SHARD)) {
    my $s = qq{shard (-R) parameter missing } . ck_get_usage();
    my $rc = $SLIP_Utils::States::RC_BAD_ARGS;
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

my $LIMIT_SEGS = $opt_O; # Required
if (! defined($LIMIT_SEGS)) {
    my $s = qq{limit_segs (-O) param missing: } . ck_get_usage();
    my $rc = $SLIP_Utils::States::RC_BAD_ARGS;
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

my $CHECK_INDEX = $opt_C; # optional

if ($INTERACTIVE) {
    my $s = q{Are you running from a shell that can see the Solr index directory for `ls`? [N] };
    __confirm($s) unless($NOOP);
}

# Do not try to check this shard while I am running already
my $lock_str = "run-" . $RUN . "-shard-" . $SHARD;
my $Lock_File = "/tmp/check-" . $lock_str . "-lock.sem";
my $Semaphore = new Semaphore($Lock_File);
if (! $Semaphore) {
    __output("Could not get semaphore file: $Lock_File\n");
    exit 0;
}
END {
    $Semaphore->unlock()
        if ($Semaphore);
}

if (defined($opt_d)) {
    $ENV{'DEBUG'} .= 'lsdb,me';
}

my $C = new Context;
my $SCRIPTS_DIR = $ENV{'SDRROOT'} . '/slip/scripts/';

my $logdir = Utils::get_tmp_logdir();
my $Child_Err_File = qq{$logdir/check_child_error-$SHARD-$$-} . Utils::Time::iso_Time('sdt') . q{.log};
END{
    `rm -f $Child_Err_File` if (-z $Child_Err_File);
}

my $config = SLIP_Utils::Common::gen_run_config('slip', $RUN);
$C->set_object('MdpConfig', $config);

my $db;
eval {
    $db = new Database($config);
};
if ($@) {
    SLIP_Utils::Common::Log_database_connection_error($C, qq{check-j run=$RUN shard=$SHARD}, $@);
    exit $SLIP_Utils::States::RC_DATABASE_CONNECT;
}
$C->set_object('Database', $db);

my $DBH = $db->get_DBH();
my $HOST = SLIP_Utils::Common::Solr_host_from_shard($C, $SHARD);

my $check_enabled = 
  (
   $NOOP
   ||
   $INTERACTIVE
   ||
   Db::Select_check_enabled($C, $DBH, $RUN, $SHARD)
  );

# Adjust $LIMIT_SEGS for full optimize case?
if ($check_enabled) {
    eval {
        if (Scheduler::check_do_full_optimize($C, $RUN, $SHARD)) {
            $LIMIT_SEGS = 1;
        }
    };
    if ($@) {
        Log_check_error($C, $RUN, $SHARD, "Schedule file error:$@");
        handle_check_rc($C, $DBH, $RUN, $SHARD, $HOST, $SLIP_Utils::States::RC_BAD_SCHED_FILE);
    }
    
    eval {
        my $s =
          "check-j: CHECK shard=$SHARD CheckIndex="
            . ($CHECK_INDEX ? 'yes' : 'no')
              . " check for segments=$LIMIT_SEGS"
                . ($NOOP ? " ---> NOOP\n" : "\n") ;
        __output($s);
        
        handle_check_rc($C, $DBH, $RUN, $SHARD, $HOST,
                        c_check($C, $RUN, $DBH, $SHARD, $LIMIT_SEGS, $CHECK_INDEX));
    };
    if ($@) {
        Log_check_error($C, $RUN, $SHARD, "Critical error: $@");
        handle_check_rc($C, $DBH, $RUN, $SHARD, $HOST, $SLIP_Utils::States::RC_CRITICAL_ERROR);
        # NOTREACHED
    }
}
else {
    __output("check-j not enabled for shard=$SHARD\n");
}

exit 0;

#
# --------------------- S u b r o t i n e s   -------------------------
#

# ---------------------------------------------------------------------

=item handle_check_rc

Description

=cut

# ---------------------------------------------------------------------
sub handle_check_rc {
    my ($C, $dbh, $run, $shard, $host, $rc) = @_;

    while (Utils::GlobalSwitch::cron_jobs_disabled('slip')) {
        __output("  wait Check done: STOPSLIP\n");
        sleep STOPSLIP_CSLEEP_WAIT;
    }

    # Have we lost the database?
    my $state = 'undef';
    my $connect_error = 0;
    my $connection_still_alive = $dbh->ping();

    if ($connection_still_alive) {
        if ($rc > 0) {
            # Set shard state to 'error'
            $state = $SLIP_Utils::States::Sht_Check_Error;
        }
        else {
            # Set shard state to 'done'
            $state = $SLIP_Utils::States::Sht_Checked;
            # Record the time this successful optimize
            Db::set_shard_check_done($C, $dbh, $run, $shard);
        }

        # Set terminal state
        Db::set_shard_check_state($C, $dbh, $run, $shard, $state);
        # Self-stop.  driver-j also disables check-j as extra measure.
        Db::set_check_enabled($C, $dbh, $run, $shard, 0);
    }
    else {
        $connect_error = 1;
    }

    # Log
    my $s = SLIP_Utils::Common::stage_rc_to_string($rc)
        . qq{ run=$run shard=$shard host=$host}
          . qq{ [stop][self] State=$state connect_error=$connect_error};
    __output(qq{$s\n});
    __non_interactive_err_output($rc, $s);

    if ($connect_error || ($rc > 0)) {
        Log_check_error($C, $run, $shard, $s);
    }
    else {
        Log_check($C, $run, $shard, $s);
    }

    exit $rc if ($rc > 0);
}

# ---------------------------------------------------------------------

=item __check_c_sysrc

Description

=cut

# ---------------------------------------------------------------------
sub __check_c_sysrc {
    my ($sysrc, $C, $run, $shard, $s) = @_;

    my $rc = 0;

    if ($sysrc > 0) {
        my $s_ref = Utils::read_file($Child_Err_File, 1, 0);
        my $ss = qq{check-j system_rc=$sysrc attempting $s run=$run shard=$shard error:$$s_ref\n};
        $rc = $SLIP_Utils::States::RC_CHILD_ERROR;
        __output($ss);
        __non_interactive_err_output($rc, $ss);
        Log_check_error($C, $run, $shard, $ss);
    }

    return $rc;
}

# ---------------------------------------------------------------------

=item __run_check_shard

Description

=cut

# ---------------------------------------------------------------------
sub __run_check_shard {
    my ($C, $run, $shard, $num_segs) = @_;

    return 0 if $NOOP;

    my $cmd = qq{$SCRIPTS_DIR/check-shard -r$run -R$shard -N$num_segs 2> $Child_Err_File};
    my $output = `$cmd 2> $Child_Err_File`;
    my $sysrc = $? >> 8;
    my $rc = __check_c_sysrc($sysrc, $C, $run, $shard, "check num_segs=$num_segs");

    if ($rc == 0) {
        my $msg = "__run_check_shard num_segs=$num_segs: " . $output;
        __output("$msg\n");
        Log_check($C, $run, $shard, $msg);
    }

    return $rc;
}

# ---------------------------------------------------------------------

=item __run_s_tomcat

Description

=cut

# ---------------------------------------------------------------------
sub __run_s_tomcat {
    my ($C, $run, $shard, $action) = @_;

    return 0 if $NOOP;

    my $rc = 0;
    my $fail_rc = ($action eq 'stop') 
      ? $SLIP_Utils::States::RC_TOMCAT_STOP_FAIL 
        : $SLIP_Utils::States::RC_TOMCAT_START_FAIL;

    my $test = ($action eq 'stop') ? 0 : 1;
    
    # Try to act on a tomcat
    my $cmd = qq{sudo /etc/init.d/tomcat-build $action $shard};
    my $output = `$cmd 2> $Child_Err_File`;

    # The rc from tomcat-build is unreliable. Test result by looking at
    # process table to make sure sure it stopped or started
    my $tomcat_pattern = $C->get_object('MdpConfig')->get('tomcat_pattern');
    $tomcat_pattern =~ s,__SHARD__,$shard,;

    my $tries = 0;
    while (1) {
        last if (SLIP_Utils::Processes::is_tomcat_running($C, $tomcat_pattern) == $test);
        sleep TOMCAT_TRIES_WAIT;
        
        $tries++;
        last if ($tries > TOMCAT_MAX_TRIES);
    }

    if ($tries > TOMCAT_MAX_TRIES) {
        $rc = $fail_rc;
        my $s = qq{check-j tomcat failed to $action run=$run shard=$shard\n};
        __output($s);
        __non_interactive_err_output($rc, $s);
        Log_check_error($C, $run, $shard, $s);
    }
    else {
        my $s = qq{check-j success: tomcat action=$action run=$run shard=$shard\n};
        __output($s);
        Log_check($C, $run, $shard, "__run_s_tomcat (action=$action): " . $output);
    }

    return $rc;
}


# ---------------------------------------------------------------------

=item __run_CheckIndex

Description

=cut

# ---------------------------------------------------------------------
sub __run_CheckIndex {
    my ($C, $run, $shard) = @_;

    return 0 if $NOOP;

    # Try to act on a tomcat
    my $cmd = $C->get_object('MdpConfig')->get('check_index_java_cmd');
    $cmd =~ s,__SHARD__,$shard,g;
    
    my $output = `$cmd 2> $Child_Err_File`;
    my $sysrc = $?;
    my $rc = __check_c_sysrc($sysrc, $C, $run, $shard, "CheckIndex");

    if ($rc == 0) {
        my $msg = qq{checkIndex sysrc="$sysrc" } . $output;
        __output("$msg\n");
        Log_check($C, $run, $shard, $msg);
    }

    return $rc;
}


# ---------------------------------------------------------------------

=item c_check

Check number of segments is correct.  If -C run CheckIndex.  Must be
run on the SAME machine running tomcat.

=cut

# ---------------------------------------------------------------------
sub c_check {
    my ($C, $run, $dbh, $shard, $num_segs, $check_index) = @_;

    # Count segments
    my $rc = __run_check_shard($C, $run, $shard, $num_segs);
    return $rc if ($rc > 0);

    # CheckIndex ?
    if ($check_index) {

        # Try to stop a tomcat to free up memory
        $rc = __run_s_tomcat($C, $run, $shard, 'stop');
        return $rc if ($rc > 0);

        # CheckIndex
        $rc = __run_CheckIndex($C, $run, $shard);
        return $rc if ($rc > 0);

        # Try to re-start a tomcat
        $rc = __run_s_tomcat($C, $run, $shard, 'start');
        return $rc if ($rc > 0);
    }

    return $rc;
}

# ---------------------------------------------------------------------

=item Log_check

Description

=cut

# ---------------------------------------------------------------------
sub Log_check {
    my ($C, $run, $shard, $s) = @_;

    my $s0 = qq{***CHECK: } . Utils::Time::iso_Time() . qq{ shard=$shard $s};
    SLIP_Utils::Log::this_string($C, $s0, 'indexer_logfile', '___RUN___', $run);
}


# ---------------------------------------------------------------------

=item Log_check_error

Description

=cut

# ---------------------------------------------------------------------
sub Log_check_error {
    my ($C, $run, $shard, $error) = @_;

    my $s = qq{***CHECK [ERROR]: } . Utils::Time::iso_Time() . qq{ r=$run shard=$shard, $error};
    SLIP_Utils::Log::this_string($C, $s, 'indexer_logfile', '___RUN___', $run);
}

1;


=head1 AUTHOR

Phillip Farber, University of Michigan, pfarber@umich.edu

=head1 COPYRIGHT

Copyright 2009-10 ©, The Regents of The University of Michigan, All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut



