#!/usr/bin/env perl

=head1 NAME

driver-j

=head1 USAGE

# driver-j -r run

=head1 DESCRIPTION

Drives the process of indexing queued documents into shards,
optimizing. Optimization can be accomplished by stages or all at once
to any number of segments.

The driver takes care of enabling all configured hosts, enabling shard
indexers, enabling optimizers monitoring their progress through the
mdp.j_shard_control table.

If the driver has an error it emails and stops the run.

There is a single driver script running on a distinguished host.

=head1 OPTIONS

=over 8

=item --help

Prints this message and exits.

=back

=cut

=head1 EXAMPLES

Run this script in debug mode if ...

=over

perl foo.pl --help

=back

=cut


use strict;

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

# Perl
use Getopt::Std;
use Date::Calc qw(:all);

# App
use Utils;
use Utils::Time;
use Context;
use MdpConfig;
use Database;
use Utils::GlobalSwitch;
use Semaphore;

# Local
use Db;
use Scheduler;
use SLIP_Utils::Db_driver;
use SLIP_Utils::Common;
use SLIP_Utils::Log;

my $INTERACTIVE = $ENV{TERM};

if ($INTERACTIVE) {
    if (Utils::GlobalSwitch::cron_jobs_disabled('slip', 'STOPSLIP')) {
        __output("Cannot run driver. STOPSLIP in place!!\n");
        exit 0;
    }
}
else {
    Utils::GlobalSwitch::Exit_If_cron_jobs_disabled('STOPSLIP');
}


sub sd_get_usage {
    my $s .= qq{Usage: driver-j -r run [-d][-X][-T]
                 where -X skips the check index phase\n};
    return $s;
}

our ($opt_r, $opt_d, $opt_X, $opt_T);

my $ops = getopts('r:dXT');

my $RUN = $opt_r; # Required
if (! $RUN) {
    my $s = qq{run (-r) param missing: } . sd_get_usage();
    my $rc = $SLIP_Utils::States::RC_BAD_ARGS;
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

if (defined($opt_d)) {
    $ENV{'DEBUG'} .= 'lsdb,me';
}

my $TEST_ONLY = defined($opt_T);
exit 0 if ($TEST_ONLY);

my $SKIP_CHECKINDEX = defined($opt_X);
if ($INTERACTIVE) {
    if (! $SKIP_CHECKINDEX) {
        my $s = qq{You are running with Lucene checkIndex enabled (no -X option). Not usually what you want interactively.\n\tContinue? [N] };
        __confirm($s);
    }
    my $s = qq{You are about to run the driver at the command line.\n\tContinue? [N] };
        __confirm($s);
}

my $C = new Context;

my $config = SLIP_Utils::Common::gen_run_config('slip', $RUN);
$C->set_object('MdpConfig', $config);

my $FULL_OPTIMIZE_RUN = 0;
eval {
    my $msg;
    if (Scheduler::driver_do_full_optimize($C, $RUN, \$msg)) {
        $FULL_OPTIMIZE_RUN = 1;
        # Avoid checkIndex on full optimize days -- takes too long
        $SKIP_CHECKINDEX = 1;
        
        __output("$msg\n");
        Log_sched($C, $RUN, $msg);
    }
};
if ($@) {
    Log_sched_error($C, $RUN, $@);
    my $rc = $SLIP_Utils::States::RC_CRITICAL_ERROR;
    __non_interactive_err_output($rc, $@);

    exit $rc;
}

my $db;
eval {
    $db = new Database($config);
};
if ($@) {
    SLIP_Utils::Common::Log_database_connection_error($C, qq{driver-j run=$RUN}, $@);
    my $rc = $SLIP_Utils::States::RC_DATABASE_CONNECT;
    __non_interactive_err_output($rc, $@);

    exit $rc;
}

$C->set_object('Database', $db);
my $DBH = $db->get_DBH();

my $BASE_DIR = $ENV{'SDRROOT'} . '/slip/index/';
my @NUM_SHARDS_LIST = $config->get('num_shards_list');

my $logdir = Utils::get_tmp_logdir();
my $Child_Err_File = qq{$logdir/driver_child_error-$$-} . Utils::Time::iso_Time('sdt') . q{.log};
END{
    `rm -f $Child_Err_File` if (-z $Child_Err_File);
}

my $EMAIL_MESSAGE_BUFFER;

my $flags_dir = $config->get('shared_flags_dir');
if (! -e $flags_dir) {
    my $rc = $SLIP_Utils::States::RC_DRIVER_FLAGS_DIR;
    my $s = qq{driver-j: $flags_dir does not exist run=$RUN\n};
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

use constant CHECK_SLEEP_WAIT => 300; # 5 minutes
use constant OPTIMIZE_SLEEP_WAIT => 300; # 5 minutes
use constant INDEX_SLEEP_WAIT    => 60;  # 1 minute
use constant STOPSLIP_SLEEP_WAIT => 60;  # 1 minute

# Outta here if not enabled
__check_driver_enabled($C, $DBH, $RUN);

# Exit driver-j if another has the semaphore to prevent piling up
my $Lock_File = "/tmp/driver-$RUN-lock.sem";
my $Semaphore = new Semaphore($Lock_File);
if (! $Semaphore) {
    my $rc = $SLIP_Utils::States::RC_DRIVER_NO_SEM;

    my $s = qq{driver-j could not get semaphore run=$RUN\n};
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

# Test busy file used to communicate driver in process to Core
# snapshot release ant Tomcat restart scripts.  Also acts as a valve
# for Core Services to indicate their scripts are not available.
my $BUSY_FILE = $flags_dir . '/' . 'busy';
if (-e $BUSY_FILE) {
    my $rc =  $SLIP_Utils::States::RC_DRIVER_BUSY_FILE;
    my $s = qq{driver-j: busy file=$BUSY_FILE detected run=$RUN, exit.\n};
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

my ($INITIAL_QUEUE_SIZE, $STAGE_QUEUE_SIZE, $INITIAL_TOT_INDEXED_CT, $INITIAL_TOT_ERROR_CT) = (0, 0, 0, 0);

eval {
    my $rc = 0;
    ($INITIAL_QUEUE_SIZE, $rc) = get_Building_queue_size($C, $DBH, $RUN, $SLIP_Utils::States::St_Undefined);
    $STAGE_QUEUE_SIZE = $INITIAL_QUEUE_SIZE;
    $INITIAL_TOT_INDEXED_CT = Db::Select_indexed_tot_count($C, $DBH, $RUN);
    $INITIAL_TOT_ERROR_CT = Db::Select_tot_error_count($C, $DBH, $RUN);

    if ($rc == 0) {
        run_driver($C, $DBH, $RUN);

        $Semaphore->unlock()
            if ($Semaphore);
    }
    else {
        handle_Stage_rc($SLIP_Utils::States::St_Undefined, $rc);
        # NOTREACHED
    }
};
if ($@) {
    my $s = qq{Error running driver-j -r$RUN: $@\n};
    my $rc = $SLIP_Utils::States::RC_CRITICAL_ERROR;

    email_driver_msg($C, $s, 1);

    handle_Stage_rc($SLIP_Utils::States::St_Undefined, $rc);
    # NOTREACHED
}

exit 0;


#
# ----------------------- H a n d l e r s -----------------------------
#

# ---------------------------------------------------------------------

=item handle_Stage_rc

Description

=cut

# ---------------------------------------------------------------------
sub handle_Stage_rc {
    my ($stage, $rc) = @_;

    if ($rc > 0) {
        my $s = qq{stage=$stage error=} . SLIP_Utils::Common::stage_rc_to_string($rc);

        email_driver_msg($C, $s, 1);

        __output("$s\n");
        __non_interactive_err_output($rc, $s);

        __control_producers($C, $DBH, $RUN, $stage, 'stop');
        __control_optimizers($C, $DBH, $RUN, $stage, 'stop');

        SLIP_Utils::Db_driver::set_driver_enabled($C, $DBH, $RUN, 0);
        SLIP_Utils::Db_driver::set_driver_stage($C, $DBH, $RUN, $SLIP_Utils::States::St_Driver_ERROR);

        exit $rc;
    }
}


# ---------------------------------------------------------------------

=item run_driver

Drive the stages.  __Order_matters__

=cut

# ---------------------------------------------------------------------
sub run_driver {
    my ($C, $dbh, $run) = @_;

    my $driver_START = time();

    Log_run($C, $run);

    my $_Stage = SLIP_Utils::Db_driver::Select_driver_stage($C, $dbh, $run);

    if ($_Stage ne $SLIP_Utils::States::St_Build_Wait) {
        handle_Stage_rc($_Stage, $SLIP_Utils::States::RC_DRIVER_WRONG_STAGE);
    }
    # POSSIBLY NOTREACHED

    while (1) {

        if ($_Stage eq $SLIP_Utils::States::St_Build_Wait) {
            # Check for work
            handle_Stage_rc($_Stage, handle_Build_Wait($C, $dbh, $run));
        }
        elsif ($_Stage eq $SLIP_Utils::States::St_Building) {
            # Update shards
            handle_Stage_rc($_Stage, handle_Building($C, $dbh, $run));
        }
        elsif ($_Stage eq $SLIP_Utils::States::St_Optimizing) {
            # Optimize shards
            handle_Stage_rc($_Stage, handle_Optimizing($C, $dbh, $run));
        }
        elsif ($_Stage eq $SLIP_Utils::States::St_Checking) {
            # Count segments and maybe run Lucene CheckIndex
            handle_Stage_rc($_Stage, handle_Checking($C, $dbh, $run));
        }

        $_Stage = SLIP_Utils::Db_driver::Select_driver_stage($C, $dbh, $run);
        if ($_Stage eq $SLIP_Utils::States::St_Build_Wait) {
            # Maybe unconditionally update the full optimize schedule file
            if ($FULL_OPTIMIZE_RUN) {
                handle_Stage_rc($_Stage, handle_full_optimize_done($C, $run));
            }

            # Reset the shard states.  This will not happen if there
            # was an error so the states of individual shards will be
            # preserved.
            __Reset_shard_states($C, $dbh, $run);

            # Remove busy file
            unlink($BUSY_FILE);
            # Jump out of loop
            last;
        }
    }

    # Status
    __driver_exit_report($C, $dbh, $run, qq{driver completed successfully}, $driver_START);
}



# ---------------------------------------------------------------------

=item __driver_exit_report

Description

=cut

# ---------------------------------------------------------------------
sub __driver_exit_report {
    my ($C, $dbh, $run, $s, $start) = @_;

    if ($start) {
        my $elapsed = time() - $start;
        $elapsed = sprintf("%.2f", $elapsed/60/60);
        $s .= qq{: elapsed=$elapsed hours};


        # Sanity: Compare count of ids queued with how many indexed,
        # deleted, reindexed, or were errors.  Re-indexed ids do not
        # increase the total number of newly indexed items.
        my ($reindexed, $deleted) = get_reindexed_deleted_ct_this_run($C, $dbh, $run);
        my $newly_indexed = get_newly_indexed_ct_this_run($C, $dbh, $run);
        my $new_errors = get_new_error_ct_this_run($C, $dbh, $run);

        my $processed = $newly_indexed + $reindexed + $deleted + $new_errors;
        my $delta = $INITIAL_QUEUE_SIZE - $processed;
        my $percent_reindexed = ($INITIAL_QUEUE_SIZE > 0) ? sprintf("%.1f", ($reindexed/$INITIAL_QUEUE_SIZE) * 100) : 0;

        $s .= qq{\nqueue size=$INITIAL_QUEUE_SIZE processed=$processed delta=$delta new=$newly_indexed reindexed=$reindexed(${percent_reindexed}%) deleted=$deleted errors=$new_errors};
    }

    __output($s);
    email_driver_msg($C, $s, 0);
}

# ---------------------------------------------------------------------

=item ___rate

Description

=cut

# ---------------------------------------------------------------------
sub ___rate {
    my $start = shift;

    my $elapsed_hours = sprintf("%.2f", (time() - $start)/60/60);
    my $rate = 
      ($elapsed_hours > 0) 
        ? sprintf("%.1f", $INITIAL_QUEUE_SIZE/$elapsed_hours)
          : 0.0;

    return qq{rate=$rate docs/hour elapsed=$elapsed_hours hours};
}


# ---------------------------------------------------------------------

=item handle_Build_Wait

Build_Wait is the base stage driver-j must be at for a run to
be processed when triggered from cron.

driver-j enables several other scripts to run from cron.  They can
proceed at different paces.

=cut

# ---------------------------------------------------------------------
sub handle_Build_Wait {
    my ($C, $dbh, $run) = @_;

    my $_Stage = $SLIP_Utils::States::St_Build_Wait;
    my $_Next_Stage = $SLIP_Utils::States::St_Building;

    __output("$_Stage\n");

    __check_driver_enabled($C, $dbh, $run);

    if ($INITIAL_QUEUE_SIZE == 0) {
        # Nothing to do.  Clean exit remaining in default Build_Wait
        my $s = qq{Driver queue empty\n};

        # If this is a full-optimize run, ignore a zero-size queue and
        # proceed to the next stage to flow through to optimization.
        if (! $FULL_OPTIMIZE_RUN) {
            Log_stage($C, $run, $_Stage, $s);
            __driver_exit_report($C, $dbh, $run, $s);

            exit 0;
        }
    }
    # POSSIBLY NOTREACHED
    my $q = qq{queue size=$INITIAL_QUEUE_SIZE};
    Log_stage($C, $run, $_Stage, $q);

    my $rc = 0;
    my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

    $rc = __check_shard_errors($C, $dbh, $run, $state_record_ref);
    if ($rc == 0) {
        # Zero the rates and counts
        $rc = __Reset_stats_recording($C, $dbh, $run, $_Stage);

        if ($rc == 0) {
            # Enable producers to start running from cron
            $rc = __control_producers($C, $DBH, $RUN, $_Stage, 'start');

            # Proceed to next stage or let handle_Stage_rc deal with the
            # bad rc
            if ($rc == 0) {
                SLIP_Utils::Db_driver::set_driver_stage($C, $dbh, $run, $_Next_Stage);

                # Set busy file
                `touch $BUSY_FILE`;
            }
        }
    }

    return $rc;
}


# ---------------------------------------------------------------------

=item handle_Building

Description

=cut

# ---------------------------------------------------------------------
sub handle_Building {
    my ($C, $dbh, $run) = @_;

    my $_Stage = $SLIP_Utils::States::St_Building;
    my $_Next_Stage = $SLIP_Utils::States::St_Optimizing;

    __output("$_Stage\n");

    __check_driver_enabled($C, $dbh, $run);
    Log_stage($C, $run, $_Stage);

    my $build_START = time();

    my $rc = 0;
    my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

    $rc = __check_shard_errors($C, $dbh, $run, $state_record_ref);
    if ($rc == 0) {
        # Wait for shards to finish building (queue empty)
        $rc = __Wait_build_done($C, $dbh, $run, $_Stage, $state_record_ref);

        # Unconditionally, disable producers to stop them from running from cron
        $rc |= __control_producers($C, $dbh, $run, $_Stage, 'stop');

        if ($rc == 0) {
            # Record this finish time for all shards without errors.
            __record_shards_build_done($C, $dbh, $run);

            # Enable transition to next stage before allowing
            # optimization so sizer-j will not try to enable or commit
            # during optimization.
            SLIP_Utils::Db_driver::set_driver_stage($C, $dbh, $run, $_Next_Stage);

            # Enable optimizers to start running from cron
            $rc = __control_optimizers($C, $dbh, $run, $_Stage, 'start');
        }
    }

    Log_stage($C, $run, $_Stage, ___rate($build_START));

    return $rc;
}


# ---------------------------------------------------------------------

=item handle_Optimizing

Description

=cut

# ---------------------------------------------------------------------
sub handle_Optimizing {
    my ($C, $dbh, $run) = @_;

    my $_Stage = $SLIP_Utils::States::St_Optimizing;

    __output("$_Stage\n");

    __check_driver_enabled($C, $dbh, $run);
    Log_stage($C, $run, $_Stage);

    my $optimize_START = time();

    my $rc = 0;
    my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

    $rc = __check_shard_errors($C, $dbh, $run, $state_record_ref);
    if ($rc == 0) {
        # Wait for all shards to finish optimizing
        $rc = __Wait_optimize_done($C, $dbh, $run, $_Stage, $state_record_ref);

        # Unconditionally disable optimizers to stop them from running from cron
        $rc |= __control_optimizers($C, $dbh, $run, $_Stage, 'stop');

        if ($rc == 0) {
            my $_Next_Stage = $SLIP_Utils::States::St_Build_Wait;

            my $config = $C->get_object('MdpConfig');
            my $check_index_supported = $config->get('check_index_supported');
            if ($check_index_supported) {
                if (! $SKIP_CHECKINDEX) {
                    my $day_of_week = Day_of_Week_to_Text(Day_of_Week(Today()));
                    my $check_index_day = $config->get('check_index_day_of_week');
                    if ($day_of_week eq $check_index_day) {
                        # Enable checkers to start running from cron
                        $rc = __control_checkers($C, $dbh, $run, $_Stage, 'start');
                        $_Next_Stage = $SLIP_Utils::States::St_Checking;
                    }
                }
            }

            # Proceed to next stage.
            SLIP_Utils::Db_driver::set_driver_stage($C, $dbh, $run, $_Next_Stage);
        }
    }

    Log_stage($C, $run, $_Stage, "full=$FULL_OPTIMIZE_RUN " . ___rate($optimize_START));

    return $rc;
}


# ---------------------------------------------------------------------

=item handle_Checking

Description

=cut

# ---------------------------------------------------------------------
sub handle_Checking {
    my ($C, $dbh, $run) = @_;

    my $_Stage = $SLIP_Utils::States::St_Checking;
    my $_Next_Stage = $SLIP_Utils::States::St_Build_Wait;

    __output("$_Stage\n");

    __check_driver_enabled($C, $dbh, $run);
    Log_stage($C, $run, $_Stage);

    my $check_START = time();

    my $rc = 0;
    my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

    $rc = __check_shard_errors($C, $dbh, $run, $state_record_ref);
    if ($rc == 0) {
        # Wait for all shards to finish checking
        $rc = __Wait_check_done($C, $dbh, $run, $_Stage, $state_record_ref);

        # Unconditionally disable checkers to stop them from running from cron
        $rc |= __control_checkers($C, $dbh, $run, $_Stage, 'stop');

        if ($rc == 0) {
            # Proceed to next stage.
            SLIP_Utils::Db_driver::set_driver_stage($C, $dbh, $run, $_Next_Stage);
        }
    }

    Log_stage($C, $run, $_Stage, ___rate($check_START));

    return $rc;
}

#
# ----------------------- U t i l i t i e s ---------------------------
#
# ---------------------------------------------------------------------

=item handle_full_optimize_done

Description

=cut

# ---------------------------------------------------------------------
sub handle_full_optimize_done {
    my $C = shift;
    my $run = shift;

    my $rc = 0;

    eval {
        Scheduler::advance_full_optimize_date($C, $run);
    };
    if ($@) {
        $rc = $SLIP_Utils::States::RC_BAD_SCHED_FILE;
    }

    return $rc;
}

# ---------------------------------------------------------------------

=item __Wait_check_done

Description

=cut

# ---------------------------------------------------------------------
sub __Wait_check_done {
    my ($C, $dbh, $run, $stage) = @_;

    while (1) {
        __check_driver_enabled($C, $dbh, $run);

        my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

        my $rc = __check_shard_errors($C, $dbh, $run, $state_record_ref);
        return $rc if ($rc > 0);
        # POSSIBLY NOTREACHED

        if ($stage eq $SLIP_Utils::States::St_Checking) {
            if ($state_record_ref->{'num_checked'} == scalar(@NUM_SHARDS_LIST)) {
                return 0;
            }
            else {
                while (Utils::GlobalSwitch::cron_jobs_disabled('slip', 'STOPSLIP')) {
                    __output("  wait Checking: STOPSLIP\n");
                    sleep CHECK_SLEEP_WAIT;
                }

                __output("  wait Checking\n");
                sleep CHECK_SLEEP_WAIT;
            }
        }
        else {
            return $SLIP_Utils::States::RC_DRIVER_WRONG_STAGE;
        }
    }
}


# ---------------------------------------------------------------------

=item __Wait_optimize_done

Description

=cut

# ---------------------------------------------------------------------
sub __Wait_optimize_done {
    my ($C, $dbh, $run, $stage) = @_;

    while (1) {
        __check_driver_enabled($C, $dbh, $run);

        my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

        my $rc = __check_shard_errors($C, $dbh, $run, $state_record_ref);
        return $rc if ($rc > 0);
        # POSSIBLY NOTREACHED

        if ($stage eq $SLIP_Utils::States::St_Optimizing) {
            if ($state_record_ref->{'num_optimized'} == scalar(@NUM_SHARDS_LIST)) {
                return 0;
            }
            else {
                while (Utils::GlobalSwitch::cron_jobs_disabled('slip', 'STOPSLIP')) {
                    __output("  wait Optimizing: STOPSLIP\n");
                    sleep STOPSLIP_SLEEP_WAIT;
                }

                __output("  wait Optimizing\n");
                sleep OPTIMIZE_SLEEP_WAIT;
            }
        }
        else {
            return $SLIP_Utils::States::RC_DRIVER_WRONG_STAGE;
        }
    }
}

# ---------------------------------------------------------------------

=item __Wait_build_done

Description

=cut

# ---------------------------------------------------------------------
sub __Wait_build_done {
    my ($C, $dbh, $run, $stage) = @_;

    while (1) {
        __check_driver_enabled($C, $dbh, $run);

        my $state_record_ref = __get_shard_state_record($C, $dbh, $run);

        my $rc_0 = __check_shard_errors($C, $dbh, $run, $state_record_ref);
        return $rc_0 if ($rc_0 > 0);
        # POSSIBLY NOTREACHED

        if ($stage eq $SLIP_Utils::States::St_Building) {
            my ($current_queue_size, $rc_1) = get_Building_queue_size($C, $dbh, $run, $stage);
            return $rc_1 if ($rc_1 > 0);

            while (Utils::GlobalSwitch::cron_jobs_disabled('slip', 'STOPSLIP')) {
                __output("  wait Building: STOPSLIP\n");
                sleep STOPSLIP_SLEEP_WAIT;
            }

            if ($current_queue_size > 0) {
                __output("  wait Building\n");
                sleep INDEX_SLEEP_WAIT;
            }
            else {
                return 0;
            }
        }
        else {
            return $SLIP_Utils::States::RC_DRIVER_WRONG_STAGE;
        }
    }
}

# ---------------------------------------------------------------------

=item get_newly_indexed_ct_this_run

Description

=cut

# ---------------------------------------------------------------------
sub get_newly_indexed_ct_this_run {
    my ($C, $dbh, $run) = @_;
    
    my $j_indexed_ct = Db::Select_indexed_tot_count($C, $dbh, $run);
    return $j_indexed_ct - $INITIAL_TOT_INDEXED_CT;
}

# ---------------------------------------------------------------------

=item get_new_error_ct_this_run

Description

=cut

# ---------------------------------------------------------------------
sub get_new_error_ct_this_run {
    my ($C, $dbh, $run) = @_;
    
    my $j_error_ct = Db::Select_tot_error_count($C, $dbh, $run);
    return $j_error_ct - $INITIAL_TOT_ERROR_CT;
}

# ---------------------------------------------------------------------

=item get_reindexed_deleted_ct_this_run

Description

=cut

# ---------------------------------------------------------------------
sub get_reindexed_deleted_ct_this_run {
    my ($C, $dbh, $run) = @_;
    
    my ($tot_reindexed, $tot_deleted) = (0, 0);
    
    foreach my $__shard (@NUM_SHARDS_LIST) {
        my ($s_reindexed_ct, $s_deleted_ct) = Db::Select_shard_stats($C, $dbh, $run, $__shard);
        $tot_reindexed += $s_reindexed_ct;
        $tot_deleted += $s_deleted_ct;
    }

    return ($tot_reindexed, $tot_deleted);
}

# ---------------------------------------------------------------------

=item get_Building_queue_size

Return current queue size if non-zero.  If zero, requeue timeouts and
return queue size.

=cut

# ---------------------------------------------------------------------
sub get_Building_queue_size {
    my ($C, $dbh, $run, $stage) = @_;

    my $rc = 0;

    my ($size) = Db::Select_queue_data($C, $dbh, $run);;

    if ($size == 0) {
        # Requeue timeouts, if any
        my $timeouts = Db::Select_timeouts_count($C, $dbh, $run);
        if ($timeouts > 0) {
            my $percent_timeouts = sprintf("%.1f", ($timeouts/$STAGE_QUEUE_SIZE) * 100);
            $STAGE_QUEUE_SIZE = $timeouts;

            $rc = __requeue_timeouts($C, $dbh, $run, $stage);
            if ($rc == 0) {
                ($size) = Db::Select_queue_data($C, $dbh, $run);
                __output("     requeue $size\n");
                Log_stage($C, $run, $stage, qq{Requeue timeouts num=$size, percent=$percent_timeouts});
            }
        }
    }

    return ($size, $rc);
}


# ---------------------------------------------------------------------

=item __requeue_timeouts

Description

=cut

# ---------------------------------------------------------------------
sub __requeue_timeouts {
    my ($C, $dbh, $run, $stage) = @_;

    my $cmd = $BASE_DIR . qq{timeouts-j -r$run -Q 2>$Child_Err_File};
    my $sysrc = system($cmd);

    my $s = qq{"timeouts-j -r$run -Q"};
    my $rc = __check_sysrc($sysrc, $C, $run, $stage, $s);

    return $rc;
}


# ---------------------------------------------------------------------

=item __check_driver_enabled

Description

=cut

# ---------------------------------------------------------------------
sub __check_driver_enabled {
    my ($C, $dbh, $run) = @_;

    if (! __driver_enabled($C, $DBH, $RUN)) {
        my $rc = $SLIP_Utils::States::RC_DRIVER_DISABLED;
        my $s = qq{driver-j disabled for run=$RUN\n};
        __output($s);
        __non_interactive_err_output($rc, $s);

        exit $rc;
    }
}

# ---------------------------------------------------------------------

=item __record_shards_build_done

Description

=cut

# ---------------------------------------------------------------------
sub __record_shards_build_done {
    my ($C, $dbh, $run) = @_;

    foreach my $shard (@NUM_SHARDS_LIST) {
        my $build_state = Db::Select_shard_build_state($C, $dbh, $run, $shard);

        if ($build_state == $SLIP_Utils::States::Sht_No_Build_Error) {
            Db::set_shard_build_done($C, $dbh, $run, $shard);
        }
    }
}

# ---------------------------------------------------------------------

=item __get_shard_states

Description

=cut

# ---------------------------------------------------------------------
sub __get_shard_state_record {
    my ($C, $dbh, $run) = @_;

    my %h;

    $h{'num_errors'}    = 0;
    $h{'num_optimized'} = 0;
    $h{'num_checked'}   = 0;

    foreach my $shard (@NUM_SHARDS_LIST) {
        my $build_state    = Db::Select_shard_build_state($C, $dbh, $run, $shard);
        my $optimize_state = Db::Select_shard_optimize_state($C, $dbh, $run, $shard);
        my $check_state    = Db::Select_shard_check_state($C, $dbh, $run, $shard);

        $h{'num_errors'}    += ($build_state    == $SLIP_Utils::States::Sht_Build_Error);
        $h{'num_errors'}    += ($optimize_state == $SLIP_Utils::States::Sht_Optimize_Error);
        $h{'num_errors'}    += ($check_state    == $SLIP_Utils::States::Sht_Check_Error);

        $h{'num_optimized'} += ($optimize_state == $SLIP_Utils::States::Sht_Optimized);
        $h{'num_checked'}   += ($check_state    == $SLIP_Utils::States::Sht_Checked);
    }

    return \%h;
}


# ---------------------------------------------------------------------

=item __check_shard_errors

Description

=cut

# ---------------------------------------------------------------------
sub __check_shard_errors {
    my ($C, $dbh, $run, $state_record_ref) = @_;

    my $rc = 0;
    if ($state_record_ref->{'num_errors'} > 0) {
        $rc = $SLIP_Utils::States::RC_ERROR_SHARD_STATES;
    }

    return $rc;
}


# ---------------------------------------------------------------------

=item __driver_enabled

Is driver enabled?

=cut

# ---------------------------------------------------------------------
sub __driver_enabled {
    my ($C, $dbh, $run) = @_;

    my $enabled =
        (
         SLIP_Utils::Db_driver::Select_driver_enabled($C, $dbh, $run)
         ||
         $INTERACTIVE
        );

    return $enabled;
}


# ---------------------------------------------------------------------

=item __check_sysrc

Description

=cut

# ---------------------------------------------------------------------
sub __check_sysrc {
    my ($sysrc, $C, $run, $stage, $s) = @_;

    my $rc = 0;

    if ($sysrc > 0) {
        my $s_ref = Utils::read_file($Child_Err_File, 1, 0);
        my $ss = qq{driver-j system_rc=$sysrc attempting $s stage=$stage error:$$s_ref\n};
        $rc = $SLIP_Utils::States::RC_CHILD_ERROR;
        Log_stage($C, $run, $stage, $ss);
        __output($ss);
        __non_interactive_err_output($rc, $ss);
    }

    return $rc;
}

# ---------------------------------------------------------------------

=item __control_optimizers

Description

=cut

# ---------------------------------------------------------------------
sub __control_optimizers {
    my ($C, $dbh, $run, $stage, $option) = @_;

    my $rc = 0;

    # Start or stop the optimize-j script for each shard
    foreach my $shard (@NUM_SHARDS_LIST) {
        my $cmd = $BASE_DIR . qq{control-j -r$run -R$shard -k$option -O 2>$Child_Err_File};
        my $sysrc = system($cmd);

        my $s = qq{"control-j -r$run -R$shard -k$option -O"};
        $rc |= __check_sysrc($sysrc, $C, $run, $stage, $s);
    }

    return $rc;
}


# ---------------------------------------------------------------------

=item __control_checkers

Description

=cut

# ---------------------------------------------------------------------
sub __control_checkers {
    my ($C, $dbh, $run, $stage, $option) = @_;

    my $rc = 0;

    # Start or stop the check-j script for each shard
    foreach my $shard (@NUM_SHARDS_LIST) {
        my $cmd = $BASE_DIR . qq{control-j -r$run -R$shard -k$option -C 2>$Child_Err_File};
        my $sysrc = system($cmd);

        my $s = qq{"control-j -r$run -R$shard -k$option -C"};
        $rc |= __check_sysrc($sysrc, $C, $run, $stage, $s);
    }

    return $rc;
}


# ---------------------------------------------------------------------

=item __Reset_stats_recording

Description

=cut

# ---------------------------------------------------------------------
sub __Reset_stats_recording {
    my ($C, $dbh, $run, $stage) = @_;

    my $cmd = $BASE_DIR . qq{control-j -r$run -kresetstats 2>$Child_Err_File};
    my $sysrc = system($cmd);
    my $rc = __check_sysrc($sysrc, $C, $run, $stage, $cmd);

    return $rc;
}



# ---------------------------------------------------------------------

=item __control_producers

Description

=cut

# ---------------------------------------------------------------------
sub __control_producers {
    my ($C, $dbh, $run, $stage, $option) = @_;

    my $rc = 0;

    # Start or stop the run
    my $cmd = $BASE_DIR . qq{control-j -r$run -k$option 2>$Child_Err_File};
    my $sysrc = system($cmd);

    my $s = qq{"control-j -r$run -k$option"};
    $rc |= __check_sysrc($sysrc, $C, $run, $stage, $s);

    return $rc;
}

# ---------------------------------------------------------------------

=item __Reset_shard_states

Description

=cut

# ---------------------------------------------------------------------
sub __Reset_shard_states {
    my ($C, $dbh, $run) = @_;

    # Reset the shard states
    foreach my $shard (@NUM_SHARDS_LIST) {
        Db::Reset_shard_control($C, $dbh, $run, $shard);
    }
}


#
# ------------------------- L o g g i n g -----------------------------
#

# ---------------------------------------------------------------------

=item Log_disabled

Description

=cut

# ---------------------------------------------------------------------
sub Log_disabled {
    my ($C, $run) = @_;

    my $s = qq{***DRIVER [DISABLED]: } . Utils::Time::iso_Time() . qq{ r=$run};
    SLIP_Utils::Log::this_string($C, $s, 'driver_logfile', '___RUN___', $run);
}

# ---------------------------------------------------------------------

=item Log_run

Description

=cut

# ---------------------------------------------------------------------
sub Log_run {
    my ($C, $run) = @_;

    my $s = qq{***DRIVER [RUN]: } . Utils::Time::iso_Time() . qq{ r=$run};
    SLIP_Utils::Log::this_string($C, $s, 'driver_logfile', '___RUN___', $run);
}

# ---------------------------------------------------------------------

=item Log_sched_error

Description

=cut

# ---------------------------------------------------------------------
sub Log_sched_error {
    my ($C, $run, $error) = @_;

    my $s = qq{***DRIVER [ERROR]: } . Utils::Time::iso_Time() . qq{ r=$run $error};
    SLIP_Utils::Log::this_string($C, $s, 'driver_logfile', '___RUN___', $run);
}

# ---------------------------------------------------------------------

=item Log_sched

Description

=cut

# ---------------------------------------------------------------------
sub Log_sched {
    my ($C, $run, $msg) = @_;

    my $s = qq{***DRIVER: } . Utils::Time::iso_Time() . qq{ r=$run $msg};
    SLIP_Utils::Log::this_string($C, $s, 'driver_logfile', '___RUN___', $run);
}

# ---------------------------------------------------------------------

=item Log_stage

Description

=cut

# ---------------------------------------------------------------------
sub Log_stage {
    my ($C, $run, $stage, $extra) = @_;

    my $s = qq{***DRIVER [STAGE]: } . Utils::Time::iso_Time() . qq{ r=$run stage=$stage $extra};
    SLIP_Utils::Log::this_string($C, $s, 'driver_logfile', '___RUN___', $run);
    $EMAIL_MESSAGE_BUFFER .= qq{$s\n};
}


# ---------------------------------------------------------------------

=item email_driver_msg

Description

=cut

# ---------------------------------------------------------------------
sub email_driver_msg
{
    my $C = shift;
    my $msg = shift;
    my $error = shift;

    $msg .= qq{\n$EMAIL_MESSAGE_BUFFER};

    my $subj = $error
        ? qq{[driver] Error report -r$RUN}
            : qq{[driver] Status report -r$RUN};
    SLIP_Utils::Common::Send_email($C, 'driver', $subj, $msg);
}

1;

=head1 AUTHOR

Phillip Farber, University of Michigan, pfarber@umich.edu

=head1 COPYRIGHT

Copyright 2009-10 ©, The Regents of The University of Michigan, All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
