#!/l/local/bin/perl

=head1 NAME

delete-j

=head1 USAGE

% delete-j -r run -Iid

=head1 DESCRIPTION

Delete a document from the index

=head1 OPTIONS

=cut

use strict;

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;


# Perl
use Getopt::Std;

# App
use Utils;
use Debug::DUtils;
use Search::Constants;

use Context;
use MdpConfig;
use Database;

# Local
use SLIP_Utils::Common;
use SLIP_Utils::States;
use SLIP_Utils::Solr;

# ---------------------------------------------------------------------

=item delete_get_usage

Description

=cut

# ---------------------------------------------------------------------
sub delete_get_usage {
    my $s .= qq{Usage: delete-j -r run -I docid\n};
    return $s;
}

our ($opt_r, $opt_I);

my $ops = getopts('r:I:');

my $RUN = $opt_r; # Required
if (! $RUN) {
    my $s = delete_get_usage();
    print $s;
    exit 1;
}

my $DOCID = $opt_I; # Required
if (! $DOCID) {
    my $s = delete_get_usage();
    print $s;
    exit 1;
}

# Flush i/o
$| = 1;

my $C = new Context;

my $global_configfile = $ENV{'SDRROOT'} . qq{/slip/lib/Config/run-$RUN.conf};
my $common_configfile = $ENV{'SDRROOT'} . qq{/slip/lib/Config/common.conf};

my $CONFIG = new MdpConfig($common_configfile, $global_configfile);
$C->set_object('MdpConfig', $CONFIG);

my $db;
eval {
    $db = new Database($CONFIG);
};
if ($@) {
    SLIP_Utils::Common::Log_database_connection_error($C, 'index-j', $@);
    exit $SLIP_Utils::States::RC_DATABASE_CONNECT;
}

$C->set_object('Database', $db);

my $DBH = $db->get_DBH();

delete_Solr_doc($C, $RUN, $DOCID);


exit 0;

#
# --------------------- S u b r o t i n e s   -------------------------
#

# ---------------------------------------------------------------------

=item delete_Solr_doc

Description

=cut

# ---------------------------------------------------------------------
sub delete_Solr_doc {
    my ($C, $run, $id) = @_;

    # Find the shard containing the doc and send the delete
    my $shard = Db::Select_item_id_shard($C, $DBH, $run, $id);
    if (! $shard) {
        __output(qq{Shard for id=$id not found.\n});
        exit 1;
    }

    my $ok = __del_Delete_document($C, $run, $id, $shard);
    if ($ok) {
        Db::Delete_id_from_shard($C, $DBH, $run, $id, $shard);
        __output(qq{Deleted id=$id, shard=$shard from mdp.j_indexed\n});
    }
}


# ---------------------------------------------------------------------

=item __del_Delete_document

Description

=cut

# ---------------------------------------------------------------------
sub __del_Delete_document {
    my ($C, $run, $id, $shard) = @_;

    my ($index_state, $dummy);

    __output(qq{Solr delete id=$id shard=$shard ...});
    my $indexer = SLIP_Utils::Solr::create_shard_Indexer_by_alias($C, $shard);
    ($index_state, $dummy) = $indexer->delete_document($C, $id);

    if (Search::Constants::indexing_failed($index_state)) {
        my $s =
            qq{delete doc id=$id shard=$shard failed index_state=}
                . SLIP_Utils::Common::IXconstant2string($index_state);
        __output(qq{$s\n});
        return 0;
    }
    __output(qq{Done.\n});

    __output(qq{Solr commit shard=$shard ...});
    ($index_state, $dummy) = $indexer->commit_updates($C);
    if (Search::Constants::indexing_failed($index_state)) {
        my $s =
            qq{commit shard=$shard failed index_state=}
                . SLIP_Utils::Common::IXconstant2string($index_state);
        __output(qq{$s\n});
        return 0;
    }
    __output(qq{Done.\n});

    Log_delete($C, $run, qq{Solr/Mysql deleted, committed id=$id, shard=$shard});

    return 1;
}


# ---------------------------------------------------------------------

=item Log_delete

Description

=cut

# ---------------------------------------------------------------------
sub Log_delete{
    my ($C, $run, $s) = @_;
    SLIP_Utils::Log::this_string($C, $s, 'delete_logfile', '___RUN___', $run);
}

1;

#
# =head1 AUTHOR
#
# Phillip Farber, University of Michigan, pfarber@umich.edu
#
# =head1 COPYRIGHT
#
# Copyright 2010 Â©, The Regents of The University of Michigan, All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# =cut
#
#


