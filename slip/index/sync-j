#!/l/local/bin/perl

=head1 NAME

sync-j

=head1 USAGE

see usage

=head1 DESCRIPTION

The overall process of restoring sanity in the SLIP database and LS
Solr index is documented in The_SLIP_System.

INDEXING DATA FLOW

The data flow proceeds from

Vufind_Solr(mdp.j_vufind_timestamp)
   -> mdp.j_rights(mdp.j_rights_timestamp)
         -> mdp.j_queue[run]
               -> mdp.j_indexed[run] or mdp.j_errors[run]

When an id is processed it is removed from j_queue. It can re-enter
mdp.j_queue if it re-enters Vufind_Solr and is transferred to
mdp.j_rights and is then queued.

If there is an error the id is put into mdp.j_errors not into
mdp.j_indexed.

Re-do indexing moves from ids from mdp.j_errors back into mdp.j_queue
and reindexing is attempted.  It may or may not succeed.

This script is strictly interactive, to be run from the command line.


OTHER MODES OF sync-j

-- sync-j -r run -m indexedNINrights: report which ids in j_indexed are
missing from j_rights. If performed after j_rebuild, reported ids can
be inferred to also be missing from the Solr index.


=head1 OPTIONS

=over 8

=back

=cut

use strict;

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;


# Perl
use Getopt::Std;
use Time::HiRes;

# App
use Utils;
use Utils::Time;
use Utils::GlobalSwitch;
use Debug::DUtils;

use Context;
use MdpConfig;
use Database;

use Search::Site;
use Search::Constants;
use Search::Result::SLIP;
use Search::Searcher;

use Db;
use SLIP_Utils::Common;
use SLIP_Utils::Db_sync;
use SLIP_Utils::Db_driver;
use SLIP_Utils::Solr;
use SLIP_Utils::Log;

my $INTERACTIVE = $ENV{TERM};

if ($INTERACTIVE) {
    if (Utils::GlobalSwitch::cron_jobs_disabled('slip', 'STOPSLIP')) {
        __output("Cannot sync. STOPSLIP in place!!\n");
        exit 0;
    }
}
else {
    Utils::GlobalSwitch::Exit_If_cron_jobs_disabled('STOPSLIP');
}


# ---------------------------------------------------------------------

=item syn_get_usage

Description

=cut

# ---------------------------------------------------------------------
sub syn_get_usage {
    my $s .= qq{Usage: sync-j -r run -m{rightsNINindexed [-n]|indexedNINrights} [-T][-d]
            where rightsNINindexed: queue ids in j_rights not in j_indexed
                                       where -n checks, NO queuing

                  indexedNINrights: report ids in j_indexed not in j_rights
                  -T just test compilation and exit\n};
    return $s;
}

our ($opt_d, $opt_r, $opt_m, $opt_R, $opt_n, $opt_T);

my $ops = getopts('dr:m:R:nT');
my $g_S;

# Required
my $RUN = $opt_r;
if (! $opt_r) {
    my $s = syn_get_usage();
    print $s;
    exit 1;
}

my $CHECK = 1;

my $MODE = $opt_m;
if (! $opt_m) {
    my $s = syn_get_usage();
    print $s;
    exit 1;
}
elsif ($MODE eq 'rightsNINindexed') {
    $CHECK = defined($opt_n);
}
elsif ($MODE eq 'indexedNINrights') {
}
else {
    my $s = syn_get_usage();
    print $s;
    exit 1;
}

if ($opt_d) {
    $ENV{'DEBUG'} .= 'lsdb';
}

my $TEST_ONLY = defined($opt_T);
exit 0 if ($TEST_ONLY);

# Flush i/o
$| = 1;

my $C = new Context;

my $CONFIG = SLIP_Utils::Common::gen_run_config($RUN);
$C->set_object('MdpConfig', $CONFIG);

my $db;
eval {
    $db = new Database($CONFIG);
};
if ($@) {
    my $s = qq{database connect fail};
    __output("$s\n");
    exit 1;
}

$C->set_object('Database', $db);
my $DBH = $db->get_DBH();

# No index-j (producers) enabled
my @num_shards_list = $CONFIG->get('num_shards_list');
foreach my $shard (@num_shards_list) {
    my $shard_enabled = Db::Select_shard_enabled($C, $DBH, $RUN, $shard);
    if ($shard_enabled) {
        __output(qq{WARNING: run=$RUN shard=$shard enabled!\n});
    }
}

my $msg;
my $Q_MSG = ($CHECK ? 'DO NOT QUEUE' : 'QUEUE MISSING');
if ($MODE eq 'rightsNINindexed') {
    $msg = qq{Check ids from j_rights missing in j_indexed. $Q_MSG.\nj_indexed_temp MUST be fresh via rebuild-j\n\tOK? [N] };
}
elsif ($MODE eq 'indexedNINrights') {
    $msg = qq{Report ids from j_indexed missing in j_rights.\nj_indexed_temp MUST be fresh via rebuild-j.\n\tOK? [N] };    
}
else {
    my $s = syn_get_usage();
    print $s;
    exit 1;
}

__confirm($msg);

my $SHARD;

eval {
    if ($MODE eq 'rightsNINindexed') {
        Test_rightsNINindexed($C, $DBH, $RUN);
    }
    elsif ($MODE eq 'indexedNINrights') {
        Report_indexedNINrights($C, $DBH, $RUN);
        $CHECK = 0; # check is inherent
    }
};
if ($@) {
    die qq{CRITICAL ERROR: $@\n};
}

exit 0;

#
# --------------------- S u b r o t i n e s   -------------------------
#

# ---------------------------------------------------------------------

=item Test_rightsNINindexed

Find ids in j_rights that are not in j_indexed (for some shard) or
j_errors.  If not in j_indexed add to j_queue.

=cut

# ---------------------------------------------------------------------
sub Test_rightsNINindexed {
    my ($C, $dbh, $run) = @_;

    my $j_indexed_size = Db::Select_indexed_tot_count($C, $dbh, $run);
    my $j_rights_size = Db::Select_count_from_j_rights($C, $dbh);

    my $s0;
    $s0 = qq{Find ids from j_rights (size=$j_rights_size) not in j_indexed (size=$j_indexed_size) run=$run $Q_MSG};
    __output(qq{\n$s0\n}); 
    Log_sync($C, $run, $s0);

    my $start = time();

    my $ref_to_arr_of_hashref = 
        SLIP_Utils::Db_sync::Select_j_rights_NIN_j_indexed($C, $dbh, $run);
    
    my $ct = scalar(@$ref_to_arr_of_hashref);
    $s0 = qq{Query returned $ct ids from j_rights LEFT JOIN j_indexed_temp};
    __output(qq{$s0\n}); 
    Log_sync($C, $run, $s0);

    my ($missing_ct, $item_ct, $errors_ct) = (0, 0, 0);

    foreach my $hash_ref (@$ref_to_arr_of_hashref) {
        $item_ct++;
        
        # If this id is not in j_errors, it's missing
        my $id = $hash_ref->{'nid'};
        my $error_id = SLIP_Utils::Db_sync::Select_error_item_id($C, $dbh, $run, $id);
        if ($error_id) {
            $errors_ct++;
            $s0 = qq{  id=$id in j_rights missing from j_indexed run=$run FOUND in j_errors };
            __output(qq{$s0\n}); 
            Log_sync($C, $run, $s0);
        }
        else {
            $missing_ct++;
            $s0 = qq{  id=$id in j_rights missing from j_indexed run=$run};
            __output(qq{$s0\n}); 
            Log_sync($C, $run, $s0);

            Db::insert_queue_items($C, $dbh, $run, [$id])
                unless($CHECK);
        }
    }

    my $elapsed = sprintf("%.1f minutes", (time() - $start)/60);
    $s0 = qq{rightsNINindexed: candidates checked=$item_ct j_indexed_missing=$missing_ct j_errors_seen=$errors_ct $Q_MSG elapsed=$elapsed at } . Utils::Time::iso_Time();
    __output(qq{$s0\n});
    Log_sync($C, $run, $s0);
}


# ---------------------------------------------------------------------

=item Report_indexedNINrights

Report ids in j_indexed missing from j_rights

=cut

# ---------------------------------------------------------------------
sub Report_indexedNINrights {
    my ($C, $dbh, $run) = @_;

    my $j_indexed_size = Db::Select_indexed_tot_count($C, $dbh, $run);
    my $j_rights_size = Db::Select_count_from_j_rights($C, $dbh);

    my $s = qq{Report ids from j_indexed (size=$j_indexed_size) missing from j_rights (size=$j_rights_size) run=$run};
    __output(qq{\n$s\n}); 
    Log_sync($C, $run, $s);

    my $start = time();

    my $ref_to_arr_of_hashref = 
        SLIP_Utils::Db_sync::Select_j_indexed_NIN_j_rights($C, $dbh, $run);

    my $missing_ct = 0;

    foreach my $hash_ref (@$ref_to_arr_of_hashref) {
        my $id = $hash_ref->{'id'};
        $missing_ct++;
        $s = qq{  id=$id in j_indexed missing from j_rights run=$run};
        __output(qq{$s\n}); 
        Log_sync($C, $run, $s);
    }

    # Check j_errors as missing in j_rights

    my $elapsed = sprintf("%.1f minutes", (time() - $start)/60);
    $s = qq{indexedNINrights: missing=$missing_ct elapsed=$elapsed at } . Utils::Time::iso_Time();
    __output(qq{$s\n});
    Log_sync($C, $run, $s);
}

# ---------------------------------------------------------------------

=item Log_sync

Description

=cut

# ---------------------------------------------------------------------
sub Log_sync {
    my ($C, $run, $s) = @_;
    SLIP_Utils::Log::this_string($C, $s, 'sync_logfile', '___RUN___', $run);
}

1;

#
# =head1 AUTHOR
#
# Phillip Farber, University of Michigan, pfarber@umich.edu
#
# =head1 COPYRIGHT
#
# Copyright 2008-10 Â©, The Regents of The University of Michigan, All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# =cut
#
#


