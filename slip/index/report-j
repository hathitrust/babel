#!/l/local/bin/perl

=head1 NAME

report-j

=head1 USAGE

see usage

=head1 DESCRIPTION

What it says

=head1 OPTIONS

=over 8

=item -

see help

=back

=cut

use strict;
BEGIN {
    #$ENV{DEBUG_LOCAL} = 1;
}

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;


# Perl
use Getopt::Std;
use Time::Local;

# App
use Utils;
use Debug::DUtils;
use Context;
use MdpConfig;
use Database;
use Search::Constants;
use Utils::GlobalSwitch;
use SharedQueue;

# Local
use Db;
use Scheduler;
use SLIP_Utils::Db_driver;
use SLIP_Utils::Common;
use SLIP_Utils::States;
use SLIP_Utils::Solr;

my $INTERACTIVE = $ENV{'TERM'};
Utils::GlobalSwitch::Exit_If_cron_jobs_disabled('STOPSLIP')
  unless ($INTERACTIVE);

# Flush i/o
$| = 1;

my $MESSAGE_BUFFER = '';
my $HOST = `hostname`; $HOST =~ s,\..*$,,s;

my ($ON, $OFF) = $INTERACTIVE ? ("\033[1;31m", "\033[0m") : ('*', '');

sub __Print {
    my $msg = shift;

    if ($INTERACTIVE) {
        print qq{$msg};
    }
    else {
        $MESSAGE_BUFFER .= $msg;
    }
}

sub rep_get_usage {
    my $s = qq{Usage: report-j  -r run [-S][-C][-f][-E o|i|m|c|s|A][-d]
           where -C queries build index for num committed
                 -S statistics only
                 -f forces an email of the report
                 -E reports error ids
                      o=ocr i=indexing m=metadata c=critical s=server A=all\n};
    return $s;
}

our ($opt_r, $opt_f, $opt_E, $opt_d, $opt_C, $opt_S);

my $ops = getopts('fr:E:dCS');

# Required
my $RUN = $opt_r;
my $STATISTICS_ONLY = defined($opt_S); # optionsl
my $FORCE_EMAIL = $opt_f; # optionsl
$INTERACTIVE = 0 if ($FORCE_EMAIL);
my $COMMITTED = defined($opt_C);
if ($COMMITTED) {
    __confirm("The -C option queries the index and will leave Readers open.\nThis increases disk size by not allowing segments to be deleted.\nTomcat restart required.\n\tOK? [N] ");
}

my $ERRORS = $opt_E; # optional

if (! $RUN) {
    my $rc = $SLIP_Utils::States::RC_BAD_ARGS;
    my $s = rep_get_usage();
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

if (defined($opt_d)) {
    $ENV{'DEBUG'} .= 'lsdb,idx,doc,me';
}

my $C = new Context;

my $config = SLIP_Utils::Common::gen_run_config('slip', $RUN);
$C->set_object('MdpConfig', $config);

my $db;
eval {
    $db = new Database($config);
};
if ($@) {
    my $rc = $SLIP_Utils::States::RC_DATABASE_CONNECT;
    SLIP_Utils::Common::Log_database_connection_error($C, 'report-j', $@);
    my $s = "Database connect error: $@";
    __output($s);
    __non_interactive_err_output($rc, $s);

    exit $rc;
}

$C->set_object('Database', $db);

my $DBH = $db->get_DBH();

my $DRIVER = $config->get('driver_driven');

# -----------------------

# Improve performance
my ($Q_size, $Q_num_available, $Q_num_in_process, $Q_num_error_Redo) =
    Db::Select_queue_data($C, $DBH, $RUN);

if ($ERRORS) {
    if (! grep(/$ERRORS/, ('o', 'i', 'm', 'c', 's', 'n', 'A'))) {
        my $s = rep_get_usage();
        my $rc = $SLIP_Utils::States::RC_BAD_ARGS;

        __output($s);
        __non_interactive_err_output($rc, $s);

        exit $rc;
    }

    if ($ERRORS eq 'A') {
        report_errors($C, $DBH, $RUN);
    }
    else {
        c_report_errors($C, $DBH, $RUN, $ERRORS);
    }
}
else {
    c_report($C, $DBH, $RUN);
}


if (! $INTERACTIVE && $MESSAGE_BUFFER) {
    my $subj = qq{[SLIP] Status report ($HOST) -r$RUN};
    SLIP_Utils::Common::Send_email($C, 'report', $subj, $MESSAGE_BUFFER);
}

exit 0;

#
# --------------------- S u b r o t i n e s   -------------------------
#

# ---------------------------------------------------------------------

=item __commit

Description

=cut

# ---------------------------------------------------------------------
sub __commit {
    my ($C, $run, $shard) = @_;

    my $fail = 0;

    use constant COMMIT_TIMEOUT => 10000;

    __output(qq{commit shard=$shard\n});
    
    my $indexer = SLIP_Utils::Solr::create_shard_Indexer_by_alias($C, $shard, COMMIT_TIMEOUT);
    my ($index_state, $stats_ref) = $indexer->commit_updates($C);

    if (Search::Constants::indexing_failed($index_state)) {
        my $s = 
            qq{commit failed shard=$shard index_state=}
                . SLIP_Utils::Common::IXconstant2string($index_state);
        die $s;
    }
}

# ---------------------------------------------------------------------

=item _actual_docs_in_shard

Description

=cut

# ---------------------------------------------------------------------
sub _actual_docs_in_shard {
    my ($C, $run, $shard) = @_;

    return 0
        unless ($COMMITTED);

    __commit($C, $run, $shard);

    my $uri = $C->get_object('MdpConfig')->get('engine_for_shard_' . $shard);
    my $url = $uri . '/select/?q=*:*&start=0&rows=0';
    my $res = `curl '$url' 2>&1 /dev/null`;
    my ($num_docs_actual) = ($res =~ m,numFound="(.*?)",);

    return $num_docs_actual;
}


# ---------------------------------------------------------------------

=item _load_stats_hash

Description

=cut

# ---------------------------------------------------------------------
sub _load_stats_hash {
    my ($C, $dbh, $run) = @_;

    # Adjustment to account for undercounting elapsed sec.
    use constant ADJUST_TOTAL_TIME_FACTOR => 1.14677;
    my @num_shards_list = $C->get_object('MdpConfig')->get('num_shards_list');

    my %stats;
    foreach my $__shard (@num_shards_list) {
        # numbers from producers that have contributed to this shard
        my $rate =
            Db::Select_rate_stats($C, $dbh, $run, $__shard);
        my $s_idx_size =
            Db::Select_indexdir_size($C, $dbh, $run, $__shard);
        my ($s_num_docs, $s_doc_size, $s_doc_time, $s_idx_time, $s_tot_time) =
            Db::Select_shard_stats($C, $dbh, $run, $__shard);
        my ($s_num_errs) =
            Db::Select_error_data($C, $dbh, $run, $__shard);

        $stats{$__shard}{'num_docs_processed'} = $s_num_docs;
        $stats{$__shard}{'num_docs_committed'} = _actual_docs_in_shard($C, $run, $__shard);
        $stats{$__shard}{'num_docs_indexed'} = Db::Select_indexed_count($C, $dbh, $run, $__shard);
        $stats{$__shard}{'num_docs_timedout'} = Db::Select_timeouts_count($C, $dbh, $run, $__shard);
        $stats{$__shard}{'num_errs'} = $s_num_errs;
        $stats{$__shard}{'doc_size'} = $s_doc_size;
        $stats{$__shard}{'doc_time'} = $s_doc_time;
        $stats{$__shard}{'idx_time'} = $s_idx_time;

        $stats{$__shard}{'tot_time'} = $s_tot_time * ADJUST_TOTAL_TIME_FACTOR;
        $stats{$__shard}{'idx_size'} = $s_idx_size;
        $stats{$__shard}{'rate'} = $rate;
    }

    return \%stats;
}


# ---------------------------------------------------------------------

=item _report_totals

Description:

  totals:
          Docs: num=465423 left=0 pcnt=100% size=412.148g
          Index: size=302g
          Time: elapsed=80h finish=3h

=cut

# ---------------------------------------------------------------------
sub _report_totals {
    my ($C, $dbh, $run, $srf) = @_;

    my @num_shards_list = $C->get_object('MdpConfig')->get('num_shards_list');

    my $num_timeouts = 0;
    my $num_processed = 0;
    my $num_indexed = 0;
    my $num_errs = 0;
    my $doc_size = 0;
    my $idx_size = 0;
    my $elapsed_sec = 0;
    my $committed_docs = 0;
    my $docs_phour = 0;
    foreach my $__shard (@num_shards_list) {
        $num_errs       += $srf->{$__shard}{'num_errs'};
        $num_timeouts   += $srf->{$__shard}{'num_docs_timedout'};
        $num_indexed    += $srf->{$__shard}{'num_docs_indexed'};
        $num_processed  += $srf->{$__shard}{'num_docs_processed'};
        $doc_size       += $srf->{$__shard}{'doc_size'};
        $idx_size       += $srf->{$__shard}{'idx_size'};
        $elapsed_sec    += $srf->{$__shard}{'tot_time'};
        $committed_docs += $srf->{$__shard}{'num_docs_committed'};
        $docs_phour     += sprintf("%.0f", $srf->{$__shard}{'rate'});
    }

    my $doc_size_g  = sprintf("%.1f", $doc_size/1024/1024/1024);
    my $idx_size_g  = sprintf("%.1f", $idx_size/1024/1024/1024);

    my $total_load = $num_processed + $Q_size;

    my $docs_remaining = $total_load - $num_processed;

    my $pcnt_done = $total_load
        ? sprintf("%.8f", 100.0 - ($docs_remaining/$total_load)*100)
            : 0;
    my $pcnt = sprintf("%.2f", $pcnt_done);
    my $num_producers = __num_enabled_producers($C, $dbh, $run);

    my $real_elapsed_h = ($num_producers)
        ? sprintf("%.2f", $elapsed_sec/60/60/$num_producers)
            : 0.0;
    my $remains_h = ($docs_phour > 0)
        ? sprintf("%.1f", $docs_remaining/$docs_phour)
            : 'undef';

    my $actual;
    if ($COMMITTED) {
        my $delta = $num_indexed - $committed_docs;
        $actual = qq{ actual=$committed_docs delta=$delta};
    }
    __Print qq{\tOverall:\n};
    __Print qq{\t\tDocs:  processed=$num_processed indexed=${num_indexed}$actual timeouts=$num_timeouts errs=$num_errs left=$docs_remaining pcnt=${pcnt}% size=${doc_size_g}g docs/h=$docs_phour\n};
    __Print qq{\t\tIndex: size=${idx_size_g}g\n};
    my $e_H = __convert_hours($real_elapsed_h);
    my $r_H = __convert_hours($remains_h);
    __Print qq{\t\tTime: elapsed=$e_H remains=$r_H\n};
}


# ---------------------------------------------------------------------

=item __convert_hours

Description

=cut

# ---------------------------------------------------------------------
sub __convert_hours {
   my $hours_in = shift;

   my $days = $hours_in/24.0;
   my $hours = ($days - int($days))*24.0;
   my $minutes = ($hours - int($hours))*60;

   my $s;
   if (int($days) > 0) {
       $s .= int($days) . 'd';
   }
   if (int($hours) > 0) {
       $s .= ((int($days) > 0) ? '.' : '')
           . int($hours) . 'h';
   }
   if (int($minutes) > 0) {
       $s .= ((int($days) > 0 || int($hours) > 0) ? '.' : '')
           . int($minutes) . 'm';
   }

   return $s ? $s : 0;
}


# ---------------------------------------------------------------------

=item _report_shard

Description:

  shards:
          1: Docs: num=46542 sec/doc=1.82 k/sec=510.0 docs/h=6958
             Index: size=12g k/sec=270.877
             Ratio: i/doc=1.3

=cut

# ---------------------------------------------------------------------
sub _report_shard {
    my ($shard, $srf) = @_;

    __Print qq{\t\t$shard: };

    my $num_errs = $srf->{$shard}{'num_errs'};
    my $num_docs_timedout = $srf->{$shard}{'num_docs_timedout'};
    my $num_docs_indexed = $srf->{$shard}{'num_docs_indexed'};
    my $num_docs_committed = $srf->{$shard}{'num_docs_committed'};
    my $num_docs_processed = $srf->{$shard}{'num_docs_processed'};
    my $doc_Time = $srf->{$shard}{'doc_time'};
    my $idx_Time = $srf->{$shard}{'idx_time'};
    my $doc_size = $srf->{$shard}{'doc_size'};
    my $idx_size = $srf->{$shard}{'idx_size'};

    my $doc_psec = ($doc_Time > 0) ? sprintf("%.2f", $num_docs_processed/$doc_Time) : 0;
    my $doc_kpsec = ($doc_Time > 0) ? sprintf("%.1f", $doc_size/1024/$doc_Time) : 0;
    my $idx_size_g = sprintf("%.1f", $idx_size/1024/1024/1024);
    my $idx_kpsec = ($idx_Time > 0) ? sprintf("%.1f", $doc_size/1024/$idx_Time) : 0;
    my $ratio =  ($doc_kpsec > 0) ? sprintf("%.2f", $idx_kpsec/$doc_kpsec) : 'undef';
    my $doc_ph = sprintf("%.0f", $srf->{$shard}{'rate'});

    my $committed;
    if ($COMMITTED) {
        my ($on, $off) = ('','');
        # Do not email funny highlighting chars
        if (! $FORCE_EMAIL) {
            ($on, $off) = ($num_docs_indexed == $num_docs_committed) ? ('','') : ($ON, $OFF);
        }
        $committed = qq{ committed=$on$num_docs_committed$off};
    }

    __Print qq{\tDocs:  processed=$num_docs_processed indexed=${num_docs_indexed}$committed timeouts=$num_docs_timedout errs=$num_errs doc/sec=$doc_psec k/sec=$doc_kpsec doc/h=$doc_ph\n};
    __Print qq{\t\t\tIndex: size=${idx_size_g}g k/sec=$idx_kpsec\n};
    __Print qq{\t\t\tRatio: i/doc=$ratio\n};
}


# ---------------------------------------------------------------------

=item report_statistics

Description

=cut

# ---------------------------------------------------------------------
sub report_statistics {
    my $C = shift;
    my $dbh = shift;
    my $run = shift;

    __Print qq{\n * statistics: \n};

    my $stats_ref = _load_stats_hash($C, $dbh, $run);

    _report_totals($C, $dbh, $run, $stats_ref);

    __Print qq{\tshards:\n};
    my @num_shards_list = $C->get_object('MdpConfig')->get('num_shards_list');
    foreach my $__shard (@num_shards_list) {
        _report_shard($__shard, $stats_ref);
    }
}


# ---------------------------------------------------------------------

=item report_queue_state

Description

=cut

# ---------------------------------------------------------------------
sub report_queue_state {
    my ($C, $dbh, $run) = @_;

    my $shared_q_size = SharedQueue::count_shared_queue_ids($C, $dbh);

    __Print qq{\n * queue state: \n\tPrimary: size=$Q_size num_available=$Q_num_available in_process=$Q_num_in_process\n};
    __Print qq{\t Shared: size=$shared_q_size\n};
}

# ---------------------------------------------------------------------

=item report_flags_state

Description

=cut

# ---------------------------------------------------------------------
sub report_flags_state {
    my ($C, $run) = @_;

    my $config = $C->get_object('MdpConfig');
    
    my $shared_flags_dir = $config->get('shared_flags_dir');
    
    my $busy = (-e "$shared_flags_dir/busy") ? 'YES' : 'no';
    my $stop = (-e "$ENV{SDRROOT}/slip/etc/STOPSLIP") ? 'YES' : 'no';
    if ($DRIVER) {
        $busy = ($HOST eq 'bubble') ? $busy : qq{Undetermined: $HOST is not bubble};
    }
    else {
        $busy = 'Not driver driven';
    }

    $stop .= " on $HOST";
    
    my $cksup = $config->get('check_index_supported');
    my $ck = "check index support=$cksup";

    my $fo;
    if ($HOST eq 'bubble') {
        $fo = "full optimize=not configured for run=$run";
        if (Scheduler::full_optimize_supported($C, $run)) {
            my $schedule_filepath = Scheduler::get_schedule_filepath($C, $run);
            my $schedule = `cat $schedule_filepath`;
            chomp($schedule);    
            my ($y, $m, $d, $h, $min, $int) = split(/\s+/, $schedule);
            my $do = Scheduler::driver_do_full_optimize($C, $run) ? "YES" : "no";
            
            $fo = "full optimize on $y/$m/$d after $h:$min at $int day intervals\n\t\t" . "? This run=$do";
        }
    }
    else {
        $fo = qq{full optimize=Undetermined: $HOST is not bubble};
    }
          
    __Print qq{\n * flags state: \n\tbusy=$busy \n\tstopped=$stop\n\t$fo\n\t$ck\n};
}

# ---------------------------------------------------------------------

=item report_errors

Description

=cut

# ---------------------------------------------------------------------
sub report_errors {
    my ($C, $dbh, $run) = @_;

    my $config = $C->get_object('MdpConfig');
    my @num_shards_list = $C->get_object('MdpConfig')->get('num_shards_list');

    __Print qq{\n * errors:\n};

    my $error_ct = 0;
    foreach my $__shard (@num_shards_list) {
        my ($num_errors, $num_I, $num_O, $num_M, $num_C, $num_S, $num_N) =
            Db::Select_error_data($C, $dbh, $run, $__shard);
        if ($num_errors) {
            __Print qq{\tshard=$__shard: num_errors=$num_errors index=$num_I ocr=$num_O metadata=$num_M critical=$num_C server=$num_S indexer_avail=$num_N\n};
            $error_ct += $num_errors;
        }
        else {
            __Print qq{\tshard=$__shard: no errors\n};
        }
    }
    __Print qq{\n\tTotal errors=$error_ct\n};
}

# ---------------------------------------------------------------------

=item __num_enabled_producers

Number of producers over all hosts running producers for this run.

=cut

# ---------------------------------------------------------------------
sub __num_enabled_producers {
    my ($C, $dbh, $run) = @_;

    my $num_producers = 0;
    my $ref_to_ary_of_hashref = Db::Select_hosts_config($C, $dbh, $run);
    foreach my $hashref (@$ref_to_ary_of_hashref) {
        my $host = $hashref->{'host'};
        if (Db::Select_host_enabled($C, $dbh, $run, $host)) {
            $num_producers += $$hashref{'num_producers'};
        }
    }
    return $num_producers;
}

# ---------------------------------------------------------------------

=item report_configuration

Description

=cut

# ---------------------------------------------------------------------
sub report_configuration {
    my ($C, $dbh, $run) = @_;

    my $config = $C->get_object('MdpConfig');
    my @num_shards_list = $config->get('num_shards_list');

    __Print qq{\n * current config:\n};

    __Print qq{\tshards:\n};

    foreach my $__shard (@num_shards_list) {
        my $engine_uri = $config->get('engine_for_shard_' . $__shard);
        my $s_enabled = Db::Select_shard_enabled($C, $dbh, $run, $__shard);
        my $opt_enabled = Db::Select_optimize_enabled($C, $dbh, $run, $__shard);
        my $ck_enabled = Db::Select_check_enabled($C, $dbh, $run, $__shard);
        
        my $e;
        if (! $s_enabled) {
            $e = 'disabled';
        }
        else {
            $e = Db::shard_is_suspended($C, $dbh, $run, $__shard) ? 'suspended' : 'enabled';
        }

        __Print qq{\t\t$__shard: build=$e optimize=$opt_enabled check=$ck_enabled engine=$engine_uri\n};
    }

    __Print qq{\tingest hosts:\n};

    my $ref_to_ary_of_hashref = Db::Select_hosts_config($C, $dbh, $run);

    foreach my $hashref (@$ref_to_ary_of_hashref) {
        my $host = $hashref->{'host'};
        my $num_producers = $hashref->{'num_producers'};
        my $h_enabled = $hashref->{'enabled'};

        my ($max_running, $num_configured, $num_running, $num_running_str);
        if ($host eq $HOST) {
            ($max_running, $num_configured, $num_running) =
                SLIP_Utils::Common::max_producers_running($C, $dbh, $run, $HOST);
            $num_running_str = qq{num_running=$num_running};
        }
        else {
            $num_running_str = qq{num_running=unknown};
        }

        my $host_line =
            sprintf("\t\t%-11s enabled=%s %-19s num_producers=%s",
                    "$host:", $h_enabled, $num_running_str, $num_producers);
        __Print qq{$host_line\n};
    }

    # Enqueuer config
    my $enquerer_enabled = Db::Select_enqueuer_enabled($C, $dbh, $run);

    __Print qq{\tqueue:\n\t\tenabled=$enquerer_enabled\n};

    # j_rights config
    my $rights_enabled = Db::Select_rights_enabled($C, $dbh);

    my $v_timestamp = Db::Select_vSolr_timestamp($C, $dbh);
    my $r_timestamp = Db::Select_j_rights_timestamp($C, $dbh, $run);
    my $j_rights_size = Db::Select_count_from_j_rights($C, $dbh);

    __Print qq{\trights:\n\t\tenabled=$rights_enabled\n};
    __Print qq{\t\tj_rights MAX(update_time)=$v_timestamp, enqueuer-j last timestamp=$r_timestamp, j_rights size=$j_rights_size\n};

    # Driver
    # Enqueuer config
    if ($DRIVER) {
        my $driver_enabled =
            SLIP_Utils::Db_driver::Select_driver_enabled($C, $dbh, $run);
        my $driver_stage = SLIP_Utils::Db_driver::Select_driver_stage($C, $dbh, $run);
        __Print qq{\tdriver:\n\t\tenabled=$driver_enabled stage=$driver_stage\n};
    }
}


# ---------------------------------------------------------------------

=item c_report

Description

=cut

# ---------------------------------------------------------------------
sub c_report {
    my $C = shift;
    my $dbh = shift;
    my $run = shift;

    if (! $INTERACTIVE) {
        my $num_shards_enabled = Db::Select_run_num_shards_available($C, $dbh, $run);

        my $non_error_ids_queued_f_indexing =
            (($Q_size > 0) && ($Q_size > $Q_num_error_Redo));

        return unless (
                       (($num_shards_enabled > 0) && ($non_error_ids_queued_f_indexing))
                       || $FORCE_EMAIL
                      );
    }

    if ($STATISTICS_ONLY) {
        report_statistics($C, $dbh, $run);
    }
    else {
        __Print qq{\n ------- Report ($HOST): run=$run ------\n};

        report_statistics($C, $dbh, $run);

        report_configuration($C, $dbh, $run);

        report_queue_state($C, $dbh, $run);

        report_flags_state($C, $run);
    }

    __Print qq{\n};
}

# ---------------------------------------------------------------------

=item c_report_errors

Description

=cut

# ---------------------------------------------------------------------
sub c_report_errors {
    my ($C, $dbh, $run, $errors) = @_;

    my $reason;
    if ($errors eq 'o') {
        $reason = IX_DATA_FAILURE;
    }
    elsif ($errors eq 'i') {
        $reason = IX_INDEX_FAILURE;
    }
    elsif ($errors eq 'm') {
        $reason = IX_METADATA_FAILURE;
    }
    elsif ($errors eq 'c') {
        $reason = IX_CRITICAL_FAILURE;
    }
    elsif ($errors eq 's') {
        $reason = IX_SERVER_GONE;
    }
    elsif ($errors eq 'n') {
        $reason = IX_NO_INDEXER_AVAIL;
    }
    else {
        __Print rep_get_usage();
        exit 0;
    }

    my $id_arr_hashref;
    if (defined($reason)) {
        my $error_ct = 0;
        my $type = SLIP_Utils::Common::IXconstant2string($reason);

        __Print qq{\n  ------- $type  ID  List: run=$run ------\n};

        my @num_shards_list = $C->get_object('MdpConfig')->get('num_shards_list');
        foreach my $__shard (@num_shards_list) {
            $id_arr_hashref = Db::Select_error_ids($C, $dbh, $run, $__shard, $reason);

            __Print qq{\tshard=$__shard\n};
            my $s0 = sprintf("%-19s %-10s %-6s %-10s %s", 'id', 'sysid', 'pid', 'host', 'error_time');
            __Print qq{\t\t$s0\n};
            if (defined($id_arr_hashref) && scalar(@$id_arr_hashref > 0)) {
                foreach my $hashref (@$id_arr_hashref) {
                    my $id = $hashref->{'id'};
                    my $sysid = Db::Select_j_rights_id_sysid($C, $dbh, $id);
                    my $s1 = sprintf("%18s %10s %6s %10s %s", $hashref->{'id'}, $sysid, $hashref->{'pid'}, $hashref->{'host'}, $hashref->{'error_time'});
                    __Print qq{\t\t$s1\n};
                    $error_ct++;
                }
            }
            else {
                __Print qq{\t\tno errors\n};
            }
        }
        __Print qq{\n\tTotal errors=$error_ct\n};
    }
}


1;


=head1 AUTHOR

Phillip Farber, University of Michigan, pfarber@umich.edu

=head1 COPYRIGHT

Copyright 2008-9 Â©, The Regents of The University of Michigan, All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut



