#!/usr/bin/env perl

=head1 NAME

rebuild_rights-j

=head1 USAGE

% rebuild_rights-j

=head1 DESCRIPTION

See also rights-j

Drops the entire slip_rights_temp table, rebuilds it and renames it to
slip_rights. Only runs from the command line using developer personal
database password.

Phase 1 = 5.7 hours for 5980242 bib records (Thu Feb 14 10:09:54 2013)
Phase 2 = 10 hours for 10.5M ids

NOTE: Disable all indexing jobs in crontab.


=head1 OPTIONS

=over 8

=item see help

see help

=back

=over

=cut

use strict;
use warnings;

BEGIN {
    ## $ENV{DEBUG_LOCAL} = 1;
}

# ----------------------------------------------------------------------
# Set up paths for local libraries -- must come first
# ----------------------------------------------------------------------
use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

# Perl
use Getopt::Std;
use Time::HiRes;
use XML::LibXML;

# App
use Utils;
use Utils::Time;
use Debug::DUtils;
use Password;

use Context;
use MdpConfig;
use Database;

use Search::Site;
use Search::Constants;
use Search::Result::SLIP_Raw;
use Search::Result::vSolr;

# Local
use Db;
use SLIP_Utils::Common;
use SLIP_Utils::States;
use SLIP_Utils::Log;
use SLIP_Utils::Solr;
use vSolr;

# Prevent replication errors: enqueue only to one mysqlserv
if (Search::Site::get_server_site_name() ne 'macc') {
    __output("Must be run only from site=MACC\n");
    exit 0;
}

sub r_r_get_usage {
    my $s;
    $s .= qq{Usage: rebuild_rights-j -r <run> [-n][-T][-P <phase> [-f <filename>|'one']] [-d{1|2|3|4|5|6}]\n\nNOTE: verify vSolr re-indexing time\n\n};
    $s .= qq{     -T test compilation only. No operations\n};
    $s .= qq{     -P only perform phase=<phase> ('one' or 'two')\n};
    $s .= qq{     -f <filename> from which to load records for Phase=two or 'one' for result of -P {one|Both}\n};
    $s .= qq{     -n CREATE slip_rights_temp, NO RENAME slip_rights_temp, NO DROP slip_rights\n};
    $s .= qq{     -d options\n};
    $s .= qq{           1: me\n};
    $s .= qq{           2: me,lsdb\n};
    $s .= qq{           3: me,vsolr\n};
    $s .= qq{           4: me,vsolrlibxml\n};
    $s .= qq{           5: me,query\n};
    $s .= qq{           6: me,query,response\n};
    return $s;
}

our ($opt_d, $opt_n, $opt_T, $opt_r, $opt_P, $opt_f);

my $ops = getopts('d:nTr:P:f:');
my $FORCE_EMAIL = 0;

if ($opt_d) {
    if ($opt_d == 1) {
        $ENV{'DEBUG'} .= 'me';
    }
    elsif ($opt_d == 2) {
        $ENV{'DEBUG'} .= 'me,lsdb';
    }
    elsif ($opt_d == 3) {
        $ENV{'DEBUG'} .= 'me,vsolr';
    }
    elsif ($opt_d == 4) {
        $ENV{'DEBUG'} .= 'me,vsolrlibxml';
    }
    elsif ($opt_d == 5) {
        $ENV{'DEBUG'} .= 'me,query';
    }
    elsif ($opt_d == 6) {
        $ENV{'DEBUG'} .= 'me,query,response';
    }
}

use constant STOPSLIP_SLEEP_WAIT => 60;

my $RUN = $opt_r;
my $CHECK = 0;
my $PHASE = 'Both';
my $REBUILD = 1;


if (! defined($RUN)) {
    my $s = r_r_get_usage();
    __output(qq{Missing run (-r) argument\n} . $s);
    exit $SLIP_Utils::States::RC_BAD_ARGS;
}

if (defined($opt_n)) {
    $CHECK = 1;
}

if (defined($opt_P)) {
    $PHASE = $opt_P;
    if ($PHASE !~ m,(Both|one|two),) {
        __output("Invalid Phase=$PHASE.\n");
        exit $SLIP_Utils::States::RC_BAD_ARGS;
    }
}

my $TEST_ONLY = defined($opt_T);
exit 0 if ($TEST_ONLY);


my $DEBUG_TINY = 0;
my $TINY_SLICE_NUM = 10;
my $TINY_SLICE_SIZE = 1000;
my $SLICE_SIZE = $DEBUG_TINY ? $TINY_SLICE_SIZE : 1000;

my $C = new Context;

# Any run number will do to grab common.conf
my $config = SLIP_Utils::Common::gen_SLIP_config($RUN);
$C->set_object('MdpConfig', $config);

my $RIGHTS_LOGFILE_KEY = 'rights_rebuild_logfile';

my $DBH = '';
my $INIT_MSG;
my $NOW_TIMESTAMP = Utils::Time::iso_Time('date');
my $VSOLR_FILENAME = $ENV{SDRROOT} . qq{/logs/slip/run-rights/slip-rebuild-rights-vsolr-ids-$NOW_TIMESTAMP.txt};
my ($LOG_FILENAME) = SLIP_Utils::Log::full_log_filepath($C, $RIGHTS_LOGFILE_KEY, '___RUN___', 'rights');

eval {
    # Build from 00000000
    $INIT_MSG = qq{Today is $NOW_TIMESTAMP. Rebuild. Phases=$PHASE. } . qq{Query will be ['00000000' TO *]};
    my $confirm_msg;

    if ($CHECK) {
        $confirm_msg = "\n$INIT_MSG\nCHECK=1 DROP/CREATE slip_rights_temp\n  => NO RENAME slip_rights_temp, NO DROP slip_rights? [N] "
    }
    else {
        $confirm_msg = "\n$INIT_MSG\nCHECK=0 RENAME slip_rights_temp to slip_rights\n  => DROP slip_rights? [N] ";
    }
    __confirm($confirm_msg);
    r_r_rights_Log($C, "$confirm_msg");

    if ($PHASE =~ m,(Both|two),) {
        my $filename = $opt_f;
        if (! defined($filename)) {
            __output("Missing -f <filename> arg.\n");
            exit $SLIP_Utils::States::RC_BAD_ARGS;
        }
        elsif ($filename eq 'one') {
            __confirm("OK to use $VSOLR_FILENAME for records source? [N] ");
            if (! -e $VSOLR_FILENAME) {
                __output("$VSOLR_FILENAME does not exist.\n");
                exit $SLIP_Utils::States::RC_BAD_ARGS;
            }
        }
        else {
            if (! -e $filename) {
                __output("$filename does not exist.\n");
                exit $SLIP_Utils::States::RC_BAD_ARGS;
            }
            else {
                $VSOLR_FILENAME = $filename;
            }
        }

        # DROP/CREATE slip_rights_temp
        $DBH = r_r_connect($C);
        if (__confirm_continue("\nDROP/CREATE slip_rights_temp? [N] ")) {
            initialize_j_rights_temp($C, $DBH);
            my $m = "DROP/CREATE slip_rights_temp\n";
            initialize_j_rights_temp($C, $DBH);
            r_r_rights_Log($C, $m);
            __output($m);
        }
    }

    #
    # Rebuild
    #
    my ($process_start, $totals_hashref) = rebuild_rights($C, $DBH);

    # DO NOT DROP slip_rights if CHECK==1. slip_rights_temp is left
    # behind until next (-R) run.
    DROP_j_rights_RENAME_j_rights_temp($C, $DBH)
      unless($CHECK);

    r_r_final_report($C, $DBH, $process_start, $totals_hashref, $CHECK);
    # Flush remaining logs to disk
    flush_r_r_rights_Log($C);
};
if ($@) {
    my $rc = $SLIP_Utils::States::RC_CRITICAL_ERROR;
    my $s = qq{CRITICAL ERROR: $@\n};
    __output($s);
    r_r_rights_Log($C, $s, 1);
    exit $rc;
}

exit 0;

#
# --------------------- S u b r o t i n e s   -------------------------
#

# ---------------------------------------------------------------------

=item r_r_connect

Description

=cut

# ---------------------------------------------------------------------
sub r_r_connect {
    my $C = shift;
    
    my $db;
    eval {
        my $whoami = `whoami`;
        chomp($whoami);
        print "Enter passwd: ";
        my $pw = Password::get_password();
        print "\n";
        unless ($pw) {
            print "missing passwd\n";
            exit 0;
        }
        $db = new Database($whoami, $pw, 'ht_web', 'mysql-sdr');
    };
    if ($@) {
        SLIP_Utils::Common::Log_database_connection_error($C, 'rebuild_rights-j', $@);
        exit $SLIP_Utils::States::RC_DATABASE_CONNECT;
    }
    
    $C->set_object('Database', $db);
    my $dbh = $C->get_object('Database')->get_DBH();
    return $dbh;
}


# ---------------------------------------------------------------------

=item r_r_rights_Log

Description

=cut

# ---------------------------------------------------------------------
my $LOG_BUFFER = '';
my $Log_buffer_size = 0;
use constant LOG_BUFFER_MAX => 100;

sub r_r_rights_Log {
    my ($C, $s, $flush) = @_;

    chomp($s);
    my $ss = qq{$s at: } . Utils::Time::iso_Time() . qq{\n};
    $LOG_BUFFER .= $ss;
    $Log_buffer_size++;
    if ($flush || ($Log_buffer_size > LOG_BUFFER_MAX)) {
        flush_r_r_rights_Log($C, , $RIGHTS_LOGFILE_KEY);
    }
}

sub flush_r_r_rights_Log {
    my ($C) = @_;

    SLIP_Utils::Log::this_string($C, $LOG_BUFFER, $RIGHTS_LOGFILE_KEY, '___RUN___', 'rights', 'no_newline');
    $LOG_BUFFER = '';
    $Log_buffer_size = 0;
}


# ---------------------------------------------------------------------

=item __hiresTime

Description

=cut

# ---------------------------------------------------------------------
sub __hiresTime
{
    my ($seconds, $microseconds) = Time::HiRes::gettimeofday();
    my $fraction = sprintf("%.8f", $microseconds/1000000);
    return sprintf("%.8f", $seconds + $fraction);
}

# ---------------------------------------------------------------------

=item initialize_j_rights_temp

Description

=cut

# ---------------------------------------------------------------------
sub initialize_j_rights_temp {
    my ($C, $dbh) = @_;
    Db::initialize_j_rights_temp($C, $dbh);
}

# ---------------------------------------------------------------------

=item DROP_j_rights_RENAME_j_rights_temp

Description

=cut

# ---------------------------------------------------------------------
sub DROP_j_rights_RENAME_j_rights_temp {
    my ($C, $dbh) = @_;
    Db::Drop_j_rights_Rename_j_rights_temp($C, $dbh);

    my $s = "Rebuild: drop slip_rights, rename slip_rights_temp";
    __output("$s\n\n");
    r_r_rights_Log($C, $s);

}

# ---------------------------------------------------------------------

=item process_parsed_result

Description

=cut

# ---------------------------------------------------------------------
sub process_parsed_result {
    my ($C, $dbh, $result_arr_ref) = @_;

    my $anomalies = 0;
    my $arr_ref_of_processed_hashref = [];

    foreach my $hash_ref (@$result_arr_ref) {
        # hash_ref contains:
        # 'sysid', 'id', 'namespace', 'ht_id_display_timestamp', 'node_content'
        my $sysid = $hash_ref->{'sysid'};
        my $timestamp_of_nid = $hash_ref->{'ht_id_display_timestamp'};

        my ($rights_hashref, $anomaly) = vSolr::process_nid_from_Solr_query_result($C, $dbh, $hash_ref);
        if (! $anomaly) {
            # Supplement rights_current database row hashref with
            # vSolr query data
            $rights_hashref->{'sysid'} = $sysid;
            $rights_hashref->{'timestamp_of_nid'} = $timestamp_of_nid;

            push(@$arr_ref_of_processed_hashref, $rights_hashref);
        }

        $anomalies += 1 if ($anomaly);
    }

    return ($arr_ref_of_processed_hashref, $anomalies);
}

# ---------------------------------------------------------------------

=item read_vsolr_ids

Description

=cut

# ---------------------------------------------------------------------
sub read_vsolr_ids {
    my ($C, $totals_hash_ref) = @_;

    my $phase = 'Read vSolr';
    my $s0 = qq{\n[BEGIN $phase]: $INIT_MSG };

    __output(qq{$s0} . Utils::Time::iso_Time() . qq{\n});
    r_r_rights_Log($C, $s0);

    if (! open(VSOLR, ">>$VSOLR_FILENAME")) {
        $s0 = qq{Failed to open $VSOLR_FILENAME for append};
        r_r_rights_Log($C, $s0, 1);
        __output("$s0\n");
        exit $SLIP_Utils::States::RC_CRITICAL_ERROR;
    }

    my $offset = 0;
    my $slice = 0;

    while (1) {
        my $slice_start = __hiresTime();

        my $searcher = SLIP_Utils::Solr::create_VuFind_Solr_Searcher_by_alias($C);
        my $rs = new Search::Result::SLIP_Raw();

        my $query = qq{q=ht_id_update:[00000000 TO *]&start=$offset&rows=$SLICE_SIZE&fl=ht_id_display,id };
        $rs = $searcher->get_Solr_raw_internal_query_result($C, $query, $rs);
        my $result_docs_arr_ref = $rs->get_result_docs();

        if (! $rs->http_status_ok()) {
            my $dump = $rs->get_failed_HTTP_dump();
            __output($dump);
            r_r_rights_Log($C, $dump, 1);
            exit $SLIP_Utils::States::RC_SOLR_ERROR;
        }
        # POSSIBLY NOTREACHED

        if (defined($result_docs_arr_ref) && scalar(@$result_docs_arr_ref)) {
            my $records = scalar(@$result_docs_arr_ref);
            $totals_hash_ref->{record_ct_1} += $records;

            foreach my $line (@$result_docs_arr_ref) {
                print VSOLR qq{$line\n};
            }
            r_r_slice_report($C, $phase, $slice_start, $records, 0, $totals_hash_ref);

            $offset += $SLICE_SIZE;
            $slice++;

            if ($DEBUG_TINY && ($slice > $TINY_SLICE_NUM)) {
                close(VSOLR);
                last;
            }
        }
        else {
            close(VSOLR);
            last;
        }
    }
}


# ---------------------------------------------------------------------

=item write_vsolr_ids

Description

=cut

# ---------------------------------------------------------------------
sub write_vsolr_ids {
    my ($C, $dbh, $totals_hash_ref) = @_;

    my $phase = 'update DB';

    my $s0 = qq{\n[BEGIN $phase] };
    __output(qq{$s0} . Utils::Time::iso_Time() . qq{\n});
    r_r_rights_Log($C, $s0);

    if (! open(VSOLR, "<$VSOLR_FILENAME")) {
        $s0 = qq{Failed to open $VSOLR_FILENAME for read};
        r_r_rights_Log($C, $s0, 1);
        __output("$s0\n");
        exit $SLIP_Utils::States::RC_CRITICAL_ERROR;
    }

    my $parser = XML::LibXML->new();
    my $xpath_doc = q{/foo/doc};

    my $slice = 0;
    my $line_slice = 0;

    while (1) {
        my $slice_start = __hiresTime();

        my $buf = '<foo>';
        while (my $line = <VSOLR>) {
            $line_slice++;
            chomp($line);
            $buf .= qq{$line};
            if ($line_slice == $SLICE_SIZE) {
                last;
            }
        }
        $buf .= q{</foo>};

        $totals_hash_ref->{record_ct_2} += $line_slice;
        $line_slice = 0;

        my ($doc_node_count, $result_ids_arr_ref, $complete_result_arr_ref) =
          Result::vSolr::parse_vsolr_response($parser, \$buf, $xpath_doc);

        # Get all nids from vSolr bib records.
        my ($ref_to_arr_of_hashref, $anomalies) =
          process_parsed_result($C, $dbh, $complete_result_arr_ref);

        $totals_hash_ref->{anomalies} += $anomalies;

        my $ids = scalar(@$ref_to_arr_of_hashref);
        if ($ids > 0) {
            $totals_hash_ref->{ids} += $ids;

            foreach my $hashref (@$ref_to_arr_of_hashref) {
                Db::Replace_j_rights_temp_id($C, $dbh, $hashref);
            }
            $slice++;

            if ($DEBUG_TINY && ($slice > $TINY_SLICE_NUM)) {
                close(VSOLR);
                last;
            }
            r_r_slice_report($C, $phase, $slice_start, $ids, $anomalies, $totals_hash_ref);
        }
        else {
            close(VSOLR);
            last;
        }
    }
}


# ---------------------------------------------------------------------

=item rebuild_rights

Description

=cut

# ---------------------------------------------------------------------
sub rebuild_rights {
    my ($C, $dbh) = @_;

    my $process_start = __hiresTime();
    my $totals_hash_ref = {'record_ct_1' => 0, 'record_ct_2' => 0, 'ids' => 0, 'anomalies' => 0};

    read_vsolr_ids($C, $totals_hash_ref) if ($PHASE eq 'Both' || $PHASE eq 'one');

    write_vsolr_ids($C, $dbh, $totals_hash_ref) if ($PHASE eq 'Both' || $PHASE eq 'two');

    # Update the vSolr timestamp to the MAX(update_time) in
    # slip_rights{_temp}. We will backtrack by 2 days from this value
    # when next we run.
    Db::update_vSolr_timestamp($C, $dbh, $REBUILD)
        unless $CHECK;

    return ($process_start, $totals_hash_ref);
}


# ---------------------------------------------------------------------

=item r_r_slice_report

Description

=cut

# ---------------------------------------------------------------------
sub r_r_slice_report {
    my ($C, $phase, $slice_start, $slice_units, $anomalies, $tref) = @_;

    my $slice_elapsed = __hiresTime() - $slice_start;
    my $idsPsec = sprintf("%.2f", ($slice_units + $anomalies)/$slice_elapsed);

    my $total_ids = $tref->{ids};
    my $total_records_1 = $tref->{record_ct_1};
    my $total_records_2 = $tref->{record_ct_2};
    my $total_anomalies = $tref->{anomalies};

    my $s = qq{Checkpoint($phase): rate=$idsPsec units/sec slice_units=$slice_units anom=$anomalies total_ids=$total_ids total_records_1=$total_records_1 total_records_2=$total_records_2 total_anomalies=$total_anomalies } . Utils::Time::iso_Time() . qq{\n};

    __output(qq{$s});
    r_r_rights_Log($C, $s);
}

# ---------------------------------------------------------------------

=item r_r_final_report

Description

=cut

# ---------------------------------------------------------------------
sub r_r_final_report {
    my ($C, $dbh, $process_start, $tref) = @_;

    my $process_elapsed = __hiresTime() - $process_start;
    my $process_elapsed_min = sprintf("%.2f", $process_elapsed/60);
    my $idsPsec = sprintf("%.2f", ($tref->{ids} + $tref->{anomalies})/$process_elapsed);

    my $size = Db::Select_count_from_j_rights_temp($C, $dbh);
    my $timestamp = Db::Select_vSolr_timestamp($C, $dbh);

    my $total_ids = $tref->{ids};
    my $total_records_1 = $tref->{record_ct_1};
    my $total_records_2 = $tref->{record_ct_2};
    my $total_anomalies = $tref->{anomalies};

    my $s =
        qq{\nFinal report: slip_rights_temp size=$size total_ids=$total_ids total_records_1=$total_records_1 total_records_2=$total_records_2 total_anomalies=$total_anomalies\n}
          . qq{\trate=$idsPsec id/sec vsolr_timestamp=$timestamp elapsed=$process_elapsed_min min\n};

    __output(qq{$s\t at } . Utils::Time::iso_Time() . qq{\n});
    r_r_rights_Log($C, $s);

    if ($FORCE_EMAIL) {
        my $HOST = `hostname`;
        $HOST =~ s,\..*$,,s;
        my $subj = qq{[SLIP] rights-j report ($HOST)};
        SLIP_Utils::Common::Send_email($C, 'report', $subj, $s);
    }
}


1;

=back

=head1 AUTHOR

Phillip Farber, University of Michigan, pfarber@umich.edu

=head1 COPYRIGHT

Copyright 2009-2010 ©, The Regents of The University of Michigan, All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
