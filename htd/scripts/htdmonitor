#!/usr/bin/env perl

use warnings;
use strict;


# --------- Monitor htd logs ---------

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

use Utils;
use RightsGlobals;

use API::HTD_Log;
use API::DbIF;

my $DBH = API::DbIF::databaseConnect('ht_maintenance');

my $GEOIP            = "$ENV{SDRROOT}/mdp-misc/scripts/geoip.pl";
my %RESOURCES        = (
                        # common
                        'COMMON'                     => {ord => 0, ct => 0},
                        type                         => {ord => 1, ct => 0},
                        aggregate                    => {ord => 2, ct => 0},
                        structure                    => {ord => 3, ct => 0},
                        # v.1 resources
                        'V.1 - dreprecated'                        => {ord => 5, ct => 0},
                        # ---> 'V.1'                        => {ord => 5, ct => 0},
                        # ---> pageimage                    => {ord => 6, ct => 0},
                        # ---> pageocr                      => {ord => 7, ct => 0},
                        # ---> pagecoordocr                 => {ord => 8, ct => 0},
                        # ---> meta                         => {ord => 9, ct => 0},
                        # ---> pagemeta                     => {ord => 10, ct => 0},
                        # v.2 resources
                        'V.2'                        => {ord => 11, ct => 0},
                        volume                       => {ord => 12, ct => 0},
                        volume_pageimage             => {ord => 13, ct => 0},
                        volume_pageocr               => {ord => 14, ct => 0},
                        volume_pagecoordocr          => {ord => 15, ct => 0},
                        volume_meta                  => {ord => 16, ct => 0},
                        volume_pagemeta              => {ord => 17, ct => 0},
                        article                      => {ord => 18, ct => 0},
                        article_alternate            => {ord => 19, ct => 0},
                        article_assets_embedded      => {ord => 20, ct => 0},
                        article_assets_supplementary => {ord => 21, ct => 0},
                        article_meta                 => {ord => 22, ct => 0},
                       );
my @FREELY_AVAILABLE = (
                        @RightsGlobals::g_creative_commons_attribute_values,
                        @RightsGlobals::g_public_domain_world_attribute_values,
                       );

my ($logdir, $today_log_file);

if ($ARGV[0]) {
    $today_log_file = $ARGV[0];
}
else {
    ($logdir, $today_log_file) = API::HTD_Log::hlog_path();
}

if (! -e $today_log_file) {
    print STDERR qq{$today_log_file does not exist!\n};
    exit 1;
}

chomp(my @UNIQUE_IP_ADDRESSES = `cat $today_log_file|cut -f1 -d' '`);
sort_uniq_ip_addr_list(\@UNIQUE_IP_ADDRESSES);

#
# Reports
#
print "\n --- log file = $today_log_file --- \n\n";

Unique_IP_Addresses();

Total_IC_RequestsServed();

Total_GET_Requests();

Total_Signed_Requests();

Total_Auth_ERRORS_ByIP_ByResource();

Total_GET_RequestsByResource();

Total_GET_RequestsBy_IP_Addr();

CrossCheck_IC_DataRequests();


exit 0;

# ---------------------------------------------------------------------
sub order_resource_array {
    map { $RESOURCES{$_}->{ct} = 0 } keys %RESOURCES;

    my @resource_arr = sort { $RESOURCES{$a}->{ord} <=> $RESOURCES{$b}->{ord} } keys %RESOURCES;
    
    return @resource_arr;
}


# ---------------------------------------------------------------------
sub sort_uniq_ip_addr_list {
    my $list_ref = shift;

    # filter
    @$list_ref = grep(/\d+\.\d+\.\d+\.\d+/, @$list_ref);
    # sort uniq
    my %h;
    foreach my $ip (@$list_ref) {
        $h{$ip}++;
    }
    @$list_ref =
      sort {
          my @a = split /\./, $a;
          my @b = split /\./, $b;
          $a[0] <=> $b[0] or
            $a[1] <=> $b[1] or
              $a[2] <=> $b[2] or
                $a[3] <=> $b[3];
      } (keys %h);
}


# ---------------------------------------------------------------------
sub get_domain {
    my $ip = shift;

    $ip =~ s,\s,,g;
    if ($ip) {
        my $regexp = qr(\cIname\s+=\s+(.*?)\.$);

        chomp(my @nslookup = `nslookup $ip`);
        foreach my $line (@nslookup) {
            if (my ($domain) = ($line =~ m,$regexp,)) {
                return $domain;
            }
        }
    }
    return 'none';
}


# ---------------------------------------------------------------------
sub get_country {
    my $ip = shift;
    $ip =~ s,\s,,g;
    if ($ip) {
        chomp(my $country = `$GEOIP $ip`);
        return $country;
    }
    return 'none';
}


# ---------------------------------------------------------------------
sub Unique_IP_Addresses {

    print "* Total unique ip = " . scalar(@UNIQUE_IP_ADDRESSES) . "\n\n";
}


# ---------------------------------------------------------------------
sub Total_GET_Requests {

    chomp(my $total = `grep GET_ $today_log_file|wc -l`);
    print "* Total successful GET_* requests = $total\n\n";
}

# ---------------------------------------------------------------------
sub __get_access_info {
    my $access_key = shift;

    my $statement = qq{SELECT name, userid, email, org FROM htd_authentication WHERE access_key=?};
    my $sth = API::DbIF::prepAndExecute($DBH, $statement, $access_key);
    my $ref_to_arr_if_hashref = $sth->fetchall_arrayref({});

    my $name = $ref_to_arr_if_hashref->[0]->{name};
    Utils::trim_spaces(\$name);
    my $userid = $ref_to_arr_if_hashref->[0]->{userid};
    Utils::trim_spaces(\$userid);
    my $email  = $ref_to_arr_if_hashref->[0]->{email};
    Utils::trim_spaces(\$email);
    my $org  = $ref_to_arr_if_hashref->[0]->{org};
    Utils::trim_spaces(\$org);

    my $info;
    if ($name) {
        $info = "$name | $org | $email";
    }
    else {
        $info = "$userid";
    }

    return $info;
}



# ---------------------------------------------------------------------
sub Total_Signed_Requests {

    chomp(my @signed_requests = `egrep "__log_client:.*?signed=1" $today_log_file`);
    # unique combination of user agent and remote address
    my %uniq_signed_requests;
    foreach my $sr (@signed_requests) {
        my ($ua, $ra, $ff) = ($sr =~ m,UA_ip=(.*?) REMOTE_ADDR=(.*?) HTTP_X_FORWARDED_FOR=(.*?)[ ],);
        my ($ak) = ($sr =~ m,access_key=(.*?)[ ],) || 0;
        $uniq_signed_requests{"$ak-$ua-$ra-$ff"} += 1;
    }
    print "* Total signed requests = " . scalar @signed_requests . "  (unique = " . scalar (keys %uniq_signed_requests) . ")\n";
    foreach my $key (keys %uniq_signed_requests) {
        my $count = $uniq_signed_requests{$key};
        my ($ak, $ua, $ra, $ff) = split(/-/, $key);
        my $ucountry = get_country($ua);
        my $udomain = get_domain($ua);
        my $rcountry = get_country($ra);
        my $rdomain = get_domain($ra);
        my $fcountry = get_country($ff);
        my $fdomain = get_domain($ff);
        my $info = __get_access_info($ak);
        print "\tU_A=$ua ($ucountry):$udomain\n\t\tR_A=$ra ($rcountry):$rdomain\n\t\tX_F_F=$ff ($fcountry):$fdomain count=$count\n\t\tinfo=$info\n";
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_GET_RequestsBy_IP_Addr {
    my $ip_hashref = shift;

    my $unique_ip_addresses_ref;

    if (! defined($ip_hashref)) {
        $unique_ip_addresses_ref = \@UNIQUE_IP_ADDRESSES;
        print "* Total successful GET_* requests by IP address\n";
    }
    else {
        @$unique_ip_addresses_ref = keys %$ip_hashref;
    }
    sort_uniq_ip_addr_list($unique_ip_addresses_ref);

    my %resource_requests_ip;
    foreach my $ip (@$unique_ip_addresses_ref) {
        chomp($resource_requests_ip{$ip} = `egrep "$ip.*?GET_" $today_log_file|wc -l`);
        if ($resource_requests_ip{$ip} > 0) {
            my $country = get_country($ip);
            my $domain = get_domain($ip);
            chomp(my @list_resources = `egrep $ip.*?GET_ $today_log_file`);
            @list_resources = map { $_ =~ m,GET_(.*?):, } @list_resources;
            Utils::sort_uniquify_list(\@list_resources);
            my $list = join(' ', @list_resources);
            print "\t$ip ($country):$domain = [" . $resource_requests_ip{$ip} . " $list]\n";
            if (defined $ip_hashref) {
                my @id_list;
                foreach my $id (keys %{$ip_hashref->{$ip}}) {
                    my $attr = $ip_hashref->{$ip}{$id};
                    push(@id_list, "$id(attr=$attr)");
                }
                my $id_list = join(' ', @id_list);
                print "\t\t$id_list\n";
            }
        }
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_IC_RequestsServed {

    my $ic_requests = `grep 'X-HathiTrust-InCopyright' $today_log_file|wc -l`;

    chomp(my @ic_request_lines = `grep 'X-HathiTrust-InCopyright' $today_log_file`);
    my %ic_ips;
    foreach my $line (@ic_request_lines) {
        my ($ip, $id, $attr) = ($line =~ m,(.*?)[ ].*?id="(.*?)"[ ]attr="(.*?)"[ ],);
        $ic_ips{$ip}{$id} = $attr;
    }

    print "* Total ic requests served = $ic_requests";
    if (scalar keys %ic_ips) {
        Total_GET_RequestsBy_IP_Addr(\%ic_ips);
    }
    else {
        print "\n";
    }
}


# ---------------------------------------------------------------------
sub Total_GET_RequestsByResource {

    print "* Total GET_* requests by resource\n";

    my @resource_arr = order_resource_array();

    foreach my $r (@resource_arr) {
        chomp($RESOURCES{$r}->{ct} = `grep -E "GET_$r:" $today_log_file|wc -l`);
        if ($r =~ m,[CV],) {
            print "\t--- " . lc($r) .  " ---\n";
        }
        else {
            print "\t$r = " . $RESOURCES{$r}->{ct} . "\n";
        }
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_Auth_ERRORS_ByIP_ByResource {

    print "* Total authNZ errors by IP by resource\n";

    my @resource_arr = order_resource_array();

    my $errors = 0;
    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        chomp(my @auth_error_lines = `egrep "$ip.*?ERROR.*?__authNZ_Success" $today_log_file`);
        # for this IP, count each type of resource that errored out
        foreach my $res (@resource_arr) {
            $RESOURCES{$res}->{ct} = scalar(grep(/resource="$res"/, @auth_error_lines)) unless ($res =~ m,^[CV],);
        }
        # for this IP get a list of unique IDs that were denied
        # for this IP, get the /originating/ IP addresses of the errors
        # for this IP, get the failure type of the error
        my @orig_IPs = ();
        my @denied_IDs = ();
        my @failpoints = ();
        foreach my $err_line (@auth_error_lines) {
            my ($ip) = ($err_line =~ m,orig=(\d+\.\d+\.\d+\.\d+),);
            push(@orig_IPs, $ip) if ($ip);

            my ($ns, $bc) = ($err_line =~ m,ns="(.*?)".*?bc="(.*?)",);
            push(@denied_IDs, "$ns.$bc");

            my ($fail) = ($err_line =~ m,failpoint=(.*?)$,);
            push(@failpoints, $fail);
        }
        Utils::sort_uniquify_list(\@denied_IDs);
        Utils::sort_uniquify_list(\@failpoints);

        sort_uniq_ip_addr_list(\@orig_IPs);
        for (my $i = 0; $i < scalar @orig_IPs; $i++) {
            my $ip = $orig_IPs[$i];
            my $country = get_country($ip);
            my $domain = get_domain($ip);
            $orig_IPs[$i] = qq{$ip ($country):$domain};
        }
        my $orig_IPs = 'from=' . join(' ', @orig_IPs);

        # for this IP, get the country and domain of the errors
        if (scalar @auth_error_lines) {
            $errors += scalar @auth_error_lines;
            my $country = get_country($ip);
            my $domain = get_domain($ip);
            print "\t$ip ($country):$domain $orig_IPs\n";
            foreach my $res (@resource_arr) {
                print "\t\t$res = $RESOURCES{$res}->{ct}\n" if ($RESOURCES{$res}->{ct} > 0);
            }
            my $num_ids = scalar(@denied_IDs );
            if ($num_ids < 7) {
                print "\t\tIDs = " . join(" ", @denied_IDs) . "\n";
            }
            else {
                print "\t\tIDs = (LARGE) count=$num_ids\n";
            }
            print "\t\tfailpoints = " . join(" ", @failpoints) . "\n";
        }
    }

    print "\ttotal = $errors\n\n";
}

# ---------------------------------------------------------------------

=item CrossCheck_IC_DataRequests

Description

=cut

# ---------------------------------------------------------------------
sub CrossCheck_IC_DataRequests {

    print "* Cross-check IC data requests\n";

    my $check_ok = 1;

    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        my $ip_fail = 0;
        print "\t$ip ";
        foreach my $resource (qw( pageimage pageocr pagecoordocr aggregate pdf )) {
            if (my $fail = _test_resource_by_ip_for_ic($DBH, $resource, $ip)) {
                print "$fail\n";
                $check_ok = 0;
                $ip_fail = 1;
            }
        }
        print "OK\n" if (! $ip_fail);
    }

    $check_ok ? print "OK\n" : print "\n*** FAIL ***\n";
}

# ---------------------------------------------------------------------

=item _test_resource_by_ip_for_ic

Description

=cut

# ---------------------------------------------------------------------
sub _test_resource_by_ip_for_ic {
    my $DBH = shift;
    my $resource = shift;
    my $ip = shift;

    my ($statement, $sth);
    my $failures = '';

    # MUST coordinate with HAuth.pm that codes permit access to
    # restricted materials.
    my @restricted_codes = (3,7,17,19,23,33,35,39,65,67,71,129,131,135,49,51,55,81,83,87,97,99,103,145,147,151,161,163,167,193,195,199,113,115,119,177,179,183,209,211,215,225,227,231,241,243,247);

    chomp(my @uniq_resource_ids_by_ip = `egrep "$ip.*?GET_$resource" $today_log_file`);
    @uniq_resource_ids_by_ip = map { $_ =~ m, id="(.*?)" , } @uniq_resource_ids_by_ip;
    Utils::sort_uniquify_list(\@uniq_resource_ids_by_ip);

    foreach my $rid (@uniq_resource_ids_by_ip) {
        my ($namespace, $id) = ($rid =~ m,^(.*?)\.(.*?)$,);
        $statement = qq{SELECT attr FROM rights_current WHERE namespace=? AND id=?};
        $sth = API::DbIF::prepAndExecute($DBH, $statement, $namespace, $id);
        my $attr = $sth->fetchrow_array();
        if (! grep(/^$attr$/, @FREELY_AVAILABLE)) {

            # check authorization for access key used to get X-HathiTrust-InCopyright
            chomp(my @access_lines = `egrep "$ip.*?X-HathiTrust-InCopyright.*?$resource.*?$id" $today_log_file`);
            # unique lines without 'seq='
            map { $_ =~ s,seq=.*?$,, } @access_lines;
            Utils::sort_uniquify_list(\@access_lines);

            my %id_hash;
            foreach my $line (@access_lines) {
                my ($key) = ($line =~ m,key=(.*?) ,);
                $statement = qq{SELECT code FROM htd_authorization WHERE access_key=?};
                $sth = API::DbIF::prepAndExecute($DBH, $statement, $key);
                my $code = $sth->fetchrow_array() || 1;

                if (! grep(/^$code$/, @restricted_codes)) {
                    my $codekey = "code=$code key=$key";
                    $id_hash{$rid}{$codekey} += 1;
                }
            }
            foreach my $id (keys %id_hash) {
                foreach my $codekey (keys %{$id_hash{$id}}) {
                    my $ct = $id_hash{$id}{$codekey};
                    $failures .= "\n\t\t--> $id $resource attr=$attr $codekey count=$ct";
                }
            }
        }
    }

    return $failures;
}

