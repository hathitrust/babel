#!/usr/bin/env perl

use warnings;
use strict;


# --------- Monitor htd logs ---------

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

use Utils;
use RightsGlobals;

use API::HTD_Log;
use API::DbIF;


my $GEOIP            = "$ENV{SDRROOT}/mdp-misc/scripts/geoip.pl";
my %RESOURCES        = (pageimage => 0, pagemeta => 0, meta => 0, structure => 0, pageocr => 0, pagecoordocr => 0, aggregate => 0,);
my @FREELY_AVAILABLE = (
                        @RightsGlobals::g_creative_commons_attribute_values, 
                        @RightsGlobals::g_public_domain_world_attribute_values,
                       );

my ($logdir, $today_log_file);

if ($ARGV[0]) {
    $today_log_file = $ARGV[0];
}
else {
    ($logdir, $today_log_file) = API::HTD_Log::hlog_path();
}

chomp(my @UNIQUE_IP_ADDRESSES = `cat $today_log_file|cut -f1 -d' '`);
sort_uniq_ip_addr_list(\@UNIQUE_IP_ADDRESSES);

#
# Reports
#
print "\n --- log file = $today_log_file --- \n\n";

Unique_IP_Addresses();

Total_GET_Requests();

Total_GET_RequestsByResource();

Total_GET_RequestsBy_IP_Addr();

Total_IC_RequestsServed();

Total_Auth_ERRORS_By_IP_ByResource();

CrossCheck_IC_DataRequests();


exit 0;

# ---------------------------------------------------------------------
sub sort_uniq_ip_addr_list {
    my $list_ref = shift;
    
    # filter
    @$list_ref = grep(/\d+\.\d+\.\d+\.\d+/, @$list_ref);
    # sort uniq
    my %h;
    foreach my $ip (@$list_ref) {
        $h{$ip}++;
    }
    @$list_ref = 
      sort {
          my @a = split /\./, $a;
          my @b = split /\./, $b;
          $a[0] <=> $b[0] or 
            $a[1] <=> $b[1] or 
              $a[2] <=> $b[2] or 
                $a[3] <=> $b[3];
      } (keys %h);
}

# ---------------------------------------------------------------------
sub Unique_IP_Addresses {
    
    print "* Total unique ip = " . scalar(@UNIQUE_IP_ADDRESSES) . "\n\n";
}


# ---------------------------------------------------------------------
sub Total_GET_Requests {

    chomp(my $total = `grep GET_ $today_log_file|wc -l`);
    print "* Total GET_* requests = $total\n\n";
}


# ---------------------------------------------------------------------
sub Total_GET_RequestsBy_IP_Addr {

    print "* Total GET_* requests by IP address\n";

    my %resource_requests_ip;
    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        chomp($resource_requests_ip{$ip} = `egrep "$ip.*?GET_" $today_log_file|wc -l`);
        if ($resource_requests_ip{$ip} > 0) {
            chomp(my $country = `$GEOIP $ip`);
            chomp(my @list_resources = `egrep $ip.*?GET_ $today_log_file| cut -f4 -d' '|sort|uniq`);
            map { s,:|GET_,,g } @list_resources;
            my $list = join(' ', @list_resources);
            print "\t$ip ($country) = " . $resource_requests_ip{$ip} . " $list\n";
        }
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_IC_RequestsServed {

    my $ic_requests = `grep 'X-HathiTrust-InCopyright' $today_log_file|wc -l`;
    print "* Total ic requests served = $ic_requests\n";
}


# ---------------------------------------------------------------------
sub Total_GET_RequestsByResource {

    print "* Total GET_* requests by resource\n";

    map { $RESOURCES{$_} = 0 } keys %RESOURCES;
      
    foreach my $r (keys %RESOURCES) {
        chomp($RESOURCES{$r} = `grep GET_$r $today_log_file|wc -l`);
        print "\t$r = " . $RESOURCES{$r} . "\n";
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_Auth_ERRORS_By_IP_ByResource {

    print "* Total authNZ errors by IP by resource\n";

    map { $RESOURCES{$_} = 0 } keys %RESOURCES;
    
    my $errors = 0;
    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        chomp(my @auth_error_lines = `egrep "$ip.*?ERROR.*?__authNZ_Success" $today_log_file`);
        foreach my $res (keys %RESOURCES) {
            $RESOURCES{$res} = scalar(grep(/resource="$res"/, @auth_error_lines));
        }
        my @orig_IPs = ();
        foreach my $err_line (@auth_error_lines) {
            my ($ip) = ($err_line =~ m,orig=(\d+\.\d+\.\d+\.\d+),);
            push(@orig_IPs, $ip) if ($ip);
        }
        sort_uniq_ip_addr_list(\@orig_IPs);
        for (my $i = 0; $i < scalar @orig_IPs; $i++) {
            my $ip = $orig_IPs[$i];
            chomp(my $country = `$GEOIP $ip`);
            $orig_IPs[$i] = qq{$ip:$country};
        }
        my $orig_IPs = 'from=' . join(' ', @orig_IPs);
        
        if (scalar @auth_error_lines) {
            $errors += scalar @auth_error_lines;
            my @domain_name = `nslookup $ip`;
            my $domain_name = grep(/in-addr.arpa\tname=/, @domain_name) || 'none';
            print "\t$ip domain=$domain_name $orig_IPs\n";
            foreach my $res (keys %RESOURCES) {
                print "\t\t$res = $RESOURCES{$res}\n" if ($RESOURCES{$res} > 0);
            }
        }
    }

    print "total = $errors\n\n";
}

# ---------------------------------------------------------------------

=item CrossCheck_IC_DataRequests

Description

=cut

# ---------------------------------------------------------------------
sub CrossCheck_IC_DataRequests {
    
    print "* Cross-check IC data requests\n";

    my $dbh = API::DbIF::databaseConnect
      (
       'mdp',
       'mdp',
       'II4md-py',
       'mysql-sdr',
      );
    my $check_ok = 1;

    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        my $ip_fail = 0;
        print "\t$ip "; 
        foreach my $resource (qw( pageimage pageocr pagecoordocr aggregate )) {
            if (my $fail = _test_resource_by_ip_for_ic($dbh, $resource, $ip)) {
                print "$fail\n";
                $check_ok = 0;
                $ip_fail = 1;
            }
        }
        print "OK\n" if (! $ip_fail);
    }

    $check_ok ? print "OK\n" : print "\n*** FAIL ***\n";
}

# ---------------------------------------------------------------------

=item _test_resource_by_ip_for_ic

Description

=cut

# ---------------------------------------------------------------------
sub _test_resource_by_ip_for_ic {
    my $dbh = shift;
    my $resource = shift;
    my $ip = shift;

    my ($statement, $sth);
    my $failures = '';
    
    chomp(my @uniq_resource_ids_by_ip = `egrep "$ip.*?GET_$resource" $today_log_file|cut -f8 -d' '|cut -f2 -d'"'|sort|uniq`);
    foreach my $id (@uniq_resource_ids_by_ip) {
        $statement = qq{SELECT attr FROM j_rights WHERE nid=?};
        $sth = API::DbIF::prepAndExecute($dbh, $statement, $id);
        my $attr = $sth->fetchrow_array();
        if (! grep(/^$attr$/, @FREELY_AVAILABLE)) {
            # check authorization for access key used to get X-HathiTrust-InCopyright
            chomp(my $access_line = `egrep "$ip.*?X-HathiTrust-InCopyright.*?$resource" $today_log_file|cut -f6,10 -d' '|sort|uniq`);
            my ($key) = ($access_line =~ m,key=(.*?) ,); 
            $statement = qq{SELECT code FROM da_authorization WHERE access_key=?};
            $sth = API::DbIF::prepAndExecute($dbh, $statement, $key);
            my $code = $sth->fetchrow_array();

            if ($code <= 1) {
                # unique lines without 'seq=' 
                chomp(my $full_line = `egrep "$ip.*?GET_$resource.*?$id" $today_log_file|cut -f1,3,4,5,6,7,8 -d' '|sort|uniq`);
                $failures .= "\n\t\t--> $full_line ATTR=$attr access_key=$key code=$code ";
            }
        }
    }
    
    return $failures;
}
    
