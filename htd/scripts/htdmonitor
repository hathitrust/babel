#!/usr/bin/env perl

use warnings;
use strict;


# --------- Monitor htd logs ---------

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

use Utils;
use RightsGlobals;

use API::HTD_Log;
use API::DbIF;


my $GEOIP            = "$ENV{SDRROOT}/mdp-misc/scripts/geoip.pl";
my %RESOURCES        = (pageimage => 0, pagemeta => 0, meta => 0, structure => 0, pageocr => 0, pagecoordocr => 0, aggregate => 0,);
my @FREELY_AVAILABLE = (
                        @RightsGlobals::g_creative_commons_attribute_values, 
                        @RightsGlobals::g_public_domain_world_attribute_values,
                       );

my ($logdir, $today_log_file);

if ($ARGV[0]) {
    $today_log_file = $ARGV[0];
}
else {
    ($logdir, $today_log_file) = API::HTD_Log::hlog_path();
}

if (! -e $today_log_file) {
    print STDERR qq{$today_log_file does not exist!\n};
    exit 1;
}

chomp(my @UNIQUE_IP_ADDRESSES = `cat $today_log_file|cut -f1 -d' '`);
sort_uniq_ip_addr_list(\@UNIQUE_IP_ADDRESSES);

#
# Reports
#
print "\n --- log file = $today_log_file --- \n\n";

Unique_IP_Addresses();

Total_GET_Requests();

Total_Signed_Requests();

Total_GET_RequestsByResource();

Total_GET_RequestsBy_IP_Addr();

Total_IC_RequestsServed();

Total_Auth_ERRORS_ByIP_ByResource();

CrossCheck_IC_DataRequests();


exit 0;

# ---------------------------------------------------------------------
sub sort_uniq_ip_addr_list {
    my $list_ref = shift;
    
    # filter
    @$list_ref = grep(/\d+\.\d+\.\d+\.\d+/, @$list_ref);
    # sort uniq
    my %h;
    foreach my $ip (@$list_ref) {
        $h{$ip}++;
    }
    @$list_ref = 
      sort {
          my @a = split /\./, $a;
          my @b = split /\./, $b;
          $a[0] <=> $b[0] or 
            $a[1] <=> $b[1] or 
              $a[2] <=> $b[2] or 
                $a[3] <=> $b[3];
      } (keys %h);
}


# ---------------------------------------------------------------------
sub get_domain {
    my $ip = shift;

    $ip =~ s,\s,,g;
    if ($ip) {
        my $regexp = qr(\cIname\s+=\s+(.*?)\.$);

        chomp(my @nslookup = `nslookup $ip`);
        foreach my $line (@nslookup) {
            if (my ($domain) = ($line =~ m,$regexp,)) {
                return $domain;
            }
        }
    }
    return 'none';
}


# ---------------------------------------------------------------------
sub get_country {
    my $ip = shift;
    $ip =~ s,\s,,g;
    if ($ip) {
        chomp(my $country = `$GEOIP $ip`);
        return $country;
    }
    return 'none';
}


# ---------------------------------------------------------------------
sub Unique_IP_Addresses {
    
    print "* Total unique ip = " . scalar(@UNIQUE_IP_ADDRESSES) . "\n\n";
}


# ---------------------------------------------------------------------
sub Total_GET_Requests {

    chomp(my $total = `grep GET_ $today_log_file|wc -l`);
    print "* Total GET_* requests = $total\n\n";
}

# ---------------------------------------------------------------------
sub Total_Signed_Requests {

    chomp(my @signed_requests = `egrep "__log_client:.*?signed=1" $today_log_file`);
    # unique combination of user agent and remote address
    my %uniq_signed_requests;
    foreach my $sr (@signed_requests) {
        my ($ua, $ra, $ff) = ($sr =~ m,UA_ip=(.*?) REMOTE_ADDR=(.*?) HTTP_X_FORWARDED_FOR=(.*?)\s*$,);
        $uniq_signed_requests{"$ua-$ra-$ff"} = 1;
    }
    print "* Total signed requests = " . scalar @signed_requests . "  (unique = " . scalar (keys %uniq_signed_requests) . ")\n";
    foreach my $key (keys %uniq_signed_requests) {
        my ($ua, $ra, $ff) = split(/-/, $key);
        my $ucountry = get_country($ua);
        my $udomain = get_domain($ua);
        my $rcountry = get_country($ra);
        my $rdomain = get_domain($ra);
        my $fcountry = get_country($ff);
        my $fdomain = get_domain($ff);
        print "\tuser_agent=$ua ($ucountry):$udomain\n\t\tremote_addr=$ra ($rcountry):$rdomain\n\t\tforwarded_for=$ff ($fcountry):$fdomain\n";
    }
    print "\n";    
}


# ---------------------------------------------------------------------
sub Total_GET_RequestsBy_IP_Addr {

    print "* Total GET_* requests by IP address\n";

    my %resource_requests_ip;
    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        chomp($resource_requests_ip{$ip} = `egrep "$ip.*?GET_" $today_log_file|wc -l`);
        if ($resource_requests_ip{$ip} > 0) {
            my $country = get_country($ip);
            my $domain = get_domain($ip);
            chomp(my @list_resources = `egrep $ip.*?GET_ $today_log_file`);
            @list_resources = map { $_ =~ m,GET_(.*?):, } @list_resources;
            Utils::sort_uniquify_list(\@list_resources);
            my $list = join(' ', @list_resources);
            print "\t$ip ($country):$domain = [" . $resource_requests_ip{$ip} . " $list]\n";
        }
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_IC_RequestsServed {

    my $ic_requests = `grep 'X-HathiTrust-InCopyright' $today_log_file|wc -l`;
    print "* Total ic requests served = $ic_requests\n";
}


# ---------------------------------------------------------------------
sub Total_GET_RequestsByResource {

    print "* Total GET_* requests by resource\n";

    map { $RESOURCES{$_} = 0 } keys %RESOURCES;
      
    foreach my $r (keys %RESOURCES) {
        chomp($RESOURCES{$r} = `grep GET_$r $today_log_file|wc -l`);
        print "\t$r = " . $RESOURCES{$r} . "\n";
    }
    print "\n";
}


# ---------------------------------------------------------------------
sub Total_Auth_ERRORS_ByIP_ByResource {

    print "* Total authNZ errors by IP by resource\n";

    map { $RESOURCES{$_} = 0 } keys %RESOURCES;
    
    my $errors = 0;
    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        chomp(my @auth_error_lines = `egrep "$ip.*?ERROR.*?__authNZ_Success" $today_log_file`);
        # for this IP, count each type of resource that errored out
        foreach my $res (keys %RESOURCES) {
            $RESOURCES{$res} = scalar(grep(/resource="$res"/, @auth_error_lines));
        }
        # for this IP get a list of unique IDs that were denied
        # for this IP, get the /originating/ IP addresses of the errors
        my @orig_IPs = ();
        my @denied_IDs = ();
        foreach my $err_line (@auth_error_lines) {
            my ($ip) = ($err_line =~ m,orig=(\d+\.\d+\.\d+\.\d+),);
            push(@orig_IPs, $ip) if ($ip);

            my ($ns, $bc) = ($err_line =~ m,ns="(.*?)".*?bc="(.*?)",);
            push(@denied_IDs, "$ns.$bc"); 
        }
        Utils::sort_uniquify_list(\@denied_IDs);

        sort_uniq_ip_addr_list(\@orig_IPs);
        for (my $i = 0; $i < scalar @orig_IPs; $i++) {
            my $ip = $orig_IPs[$i];
            my $country = get_country($ip);
            my $domain = get_domain($ip);
            $orig_IPs[$i] = qq{$ip ($country):$domain};
        }
        my $orig_IPs = 'from=' . join(' ', @orig_IPs);
        
        # for this IP, get the country and domain of the errors
        if (scalar @auth_error_lines) {
            $errors += scalar @auth_error_lines;
            my $country = get_country($ip);
            my $domain = get_domain($ip);
            print "\t$ip ($country):$domain $orig_IPs\n";
            foreach my $res (keys %RESOURCES) {
                print "\t\t$res = $RESOURCES{$res}\n" if ($RESOURCES{$res} > 0);
            }
            print "\t\tIDs = " . join(" ", @denied_IDs) . "\n";
        }
    }

    print "total = $errors\n\n";
}

# ---------------------------------------------------------------------

=item CrossCheck_IC_DataRequests

Description

=cut

# ---------------------------------------------------------------------
sub CrossCheck_IC_DataRequests {
    
    print "* Cross-check IC data requests\n";

    my $dbh = API::DbIF::databaseConnect
      (
       'mdp',
       'mdp',
       'II4md-py',
       'mysql-sdr',
      );
    my $check_ok = 1;

    foreach my $ip (@UNIQUE_IP_ADDRESSES) {
        my $ip_fail = 0;
        print "\t$ip "; 
        foreach my $resource (qw( pageimage pageocr pagecoordocr aggregate )) {
            if (my $fail = _test_resource_by_ip_for_ic($dbh, $resource, $ip)) {
                print "$fail\n";
                $check_ok = 0;
                $ip_fail = 1;
            }
        }
        print "OK\n" if (! $ip_fail);
    }

    $check_ok ? print "OK\n" : print "\n*** FAIL ***\n";
}

# ---------------------------------------------------------------------

=item _test_resource_by_ip_for_ic

Description

=cut

# ---------------------------------------------------------------------
sub _test_resource_by_ip_for_ic {
    my $dbh = shift;
    my $resource = shift;
    my $ip = shift;

    my ($statement, $sth);
    my $failures = '';

    my @restricted_codes = (7, 15, 23, 31);
    
    chomp(my @uniq_resource_ids_by_ip = `egrep "$ip.*?GET_$resource" $today_log_file`);
    @uniq_resource_ids_by_ip = map { $_ =~ m, id="(.*?)" , } @uniq_resource_ids_by_ip;
    Utils::sort_uniquify_list(\@uniq_resource_ids_by_ip);

    foreach my $rid (@uniq_resource_ids_by_ip) {
        my ($namespace, $id) = ($rid =~ m,^(.*?)\.(.*?)$,);
        $statement = qq{SELECT attr FROM rights_current WHERE namespace=? AND id=?};
        $sth = API::DbIF::prepAndExecute($dbh, $statement, $namespace, $id);
        my $attr = $sth->fetchrow_array();
        if (! grep(/^$attr$/, @FREELY_AVAILABLE)) {

            # check authorization for access key used to get X-HathiTrust-InCopyright
            chomp(my @access_lines = `egrep "$ip.*?X-HathiTrust-InCopyright.*?$resource.*?$id" $today_log_file`);
            # unique lines without 'seq='
            map { $_ =~ s,seq=.*?$,, } @access_lines;
            Utils::sort_uniquify_list(\@access_lines);

            foreach my $line (@access_lines) {
                my ($key) = ($line =~ m,key=(.*?) ,); 
                $statement = qq{SELECT code FROM da_authorization WHERE access_key=?};
                $sth = API::DbIF::prepAndExecute($dbh, $statement, $key);
                my $code = $sth->fetchrow_array() || 1;

                $failures .= "\n\t\t--> $line ATTR=$attr access_key=$key code=$code "
                  unless (grep(/^$code$/, @restricted_codes));
            }
        }
    }
    
    return $failures;
}
    
