#!/usr/bin/env perl

=head1 NAME

htdc

=head1 DESCRIPTION

This is a perl 2-legged oauth client that uses their auth credentials
as a proxy for the oauth keys and constructs a signed Data API
request.

=head1 SYNOPSIS

For example:

http://babel.hathitrust.org/cgi/htdc (present the data entry form)

http://babel.hathitrust.org/cgi/htdc?resource=pagemeta&id=mdp.39015063764644&seq=5 (send a request to Data API)

=head1 OUTPUT

The form or the resource

=cut

use strict;
use warnings;

umask 0000;

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

use CGI;
use URI;
use YAML::Any;
use Encode;

use OAuth::Lite::Consumer;
use OAuth::Lite::AuthMethod;

use Context;
use Utils;

use API::DbIF;
use API::HTD_Log;

use API::HTD::AuthDb;
use API::HTD::HConf;

my $DEBUG = 0;

BEGIN {
    ## $ENV{DEBUG_LOCAL} = 1;
    # non-US testing
    ## $ENV{REMOTE_ADDR} = '147.96.1.135'; # non-US
}

# forced upstream
my $USERID = $ENV{REMOTE_USER};

my @superusers = qw(pfarber roger rrotter);
my $DEVELOPMENT_SUPPORT = $ENV{HT_DEV} || grep(/^$USERID$/, @superusers);

my $Q = new CGI;

if (! defined $ENV{REMOTE_USER}) {
    serve_login_page();
}
elsif (! $Q->param) {
    serve_request_form_page();
    # NOTREACHED
}
else {
    my $config = Call_Handler(_get_config(), 'System configuration error');
    # POSSIBLY NOTREACHED

    my $dbh = Call_Handler(_htdc_connect($config), 'Database error');
    # POSSIBLY NOTREACHED

    my $access_key = validate_request($Q, $dbh, $config);
    # POSSIBLY NOTREACHED

    serve_Data_API_response($Q, $dbh, $config, $access_key);
    # NOTREACHED
}

exit 0;


# ---------------------------------------------------------------------

=item Call_Handler

Description

=cut

# ---------------------------------------------------------------------
sub Call_Handler {
    my $return_from_call = shift;
    my $in_case_of_error = shift;

    if (! $return_from_call) {
        serve_error_page($in_case_of_error);
    }

    return $return_from_call;
}

# ---------------------------------------------------------------------

=item validate_request

Description

=cut

# ---------------------------------------------------------------------
sub validate_request {
    my ($Q, $dbh, $config) = @_;

    # known?
    my $access_key = Call_Handler(API::HTD::AuthDb::get_access_key_by_userid($dbh, $USERID),
                                  qq{Your user ID is not registered. Please visit the <a href="/cgi/kgs/authed">registration page</a> to record your user id});

    Utils::clean_cgi_params($Q);

    # all params present?
    Call_Handler($Q->param('id'), 'Please specify an ID');

    my $resource = $Q->param('resource');
    Call_Handler($resource, 'Please specify a resource');

    if (grep(/^$resource$/, qw( pagemeta pageimage pageocr pagecoordocr ))) {
        my $seq = $Q->param('seq');
        if (! $seq) {
            Call_Handler(0, 'Please specify a sequence number');
        }
        elsif ($seq !~ m,^\d+$,) {
            Call_Handler(0, 'Please specify a sequence number that consists of only digits');
        }
    }
    else {
        $Q->Delete('seq');
    }

    unless ($DEVELOPMENT_SUPPORT) {
        foreach my $arg ( qw(format size width height res watermark) ) {
            $Q->Delete($arg);
        }
    }

    return $access_key;
}

# ---------------------------------------------------------------------

=item serve_login_page

Description

=cut

# ---------------------------------------------------------------------
sub serve_login_page {
    hLOG(qq{htdc: serve login page});

    my $page_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/htdc_login.html');

    my $wayf_link = _get_htdc_wayf_link();
    $$page_ref =~ s,___WAYF_LINK___,$wayf_link,;

    _standard_replacements($page_ref);

    print CGI::header('text/html');
    print $$page_ref;
    exit 0;
}


# ---------------------------------------------------------------------

=item serve_error_page

Description

=cut

# ---------------------------------------------------------------------
sub serve_error_page {
    my $error_message = shift;

    hLOG(qq{htdc ERROR: serve error page: $error_message});

    my $page_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/htdc_error.html');
    $$page_ref =~ s,___FAIL_REASON___,$error_message,;

    _standard_replacements($page_ref);

    print CGI::header('text/html');
    print $$page_ref;
    exit 0;
}

# ---------------------------------------------------------------------

=item serve_request_form_page

Description

=cut

# ---------------------------------------------------------------------
sub serve_request_form_page {
    hLOG(qq{htdc: serve request form});

    my $page_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/htdc_request_form.html');
    _standard_replacements($page_ref);

    print CGI::header('text/html');
    print $$page_ref;
    exit 0;
}


# ---------------------------------------------------------------------

=item _get_htdc_wayf_link

Description

=cut

# ---------------------------------------------------------------------
sub _get_htdc_wayf_link {
    my $C = shift;

    my $target = 'https://' . $ENV{HTTP_HOST} . '/cgi/kgs/authed';
    # wayf will change target /cgi into /shcgi, depending
    my $url = 'http://' . $ENV{HTTP_HOST} . '/cgi/wayf' . '?target=' . CGI::escape($target);

    return $url;
}

# ---------------------------------------------------------------------

=item _print_encoded_output

Description

=cut

# ---------------------------------------------------------------------
sub _print_encoded_output {
    my ($Q, $response) = @_;

    my $resource = $Q->param('resource');
    if (grep(/^$resource$/, qw(aggregate pageimage pdf))) {
        # Do not encode binary types
        print $response->content;
    }
    else {
        print Encode::encode_utf8(Encode::decode_utf8($response->content));
    }
}

# ---------------------------------------------------------------------

=item IPADDR_of_my_client

Description

=cut

# ---------------------------------------------------------------------
sub IPADDR_of_my_client {
    return $ENV{HTTP_X_FORWARDED_FOR} || $ENV{REMOTE_ADDR};
}

# ---------------------------------------------------------------------

=item serve_Data_API_response

Description

=cut

# ---------------------------------------------------------------------
sub serve_Data_API_response {
    my ($Q, $dbh, $config, $access_key) = @_;

    my ($request_url, $extra) = _make_Data_API_request_url($Q);

    my $consumer =  _get_consumer($dbh, $access_key);
    my $response = $consumer->request
      (
       method  => 'GET',
       url     => $request_url,
       params  => $extra,
      );

    my $full_request_url = $consumer->oauth_request->uri;
    hLOG(qq{htdc: serve_Data_API_response: full request url=$full_request_url});

    # Debug block
    if ($ENV{HT_DEV} && $DEBUG) {
        print CGI::header('text/html');
        print "<p><b>[CLIENT] sent this URL to server:</b><br/>";
        print $full_request_url;
        
        print "<p><b>[CLIENT] received this HTTP response from server:</b><br/>";
        print "<b>Status:</b> " . $response->status_line;
        print "<br/>";
        print "<b>Header:</b> " . $response->headers->as_string;
        print "<br/>";
        print "<b>Content:</b> " . $response->content;
        
        if ($Q->param('resource') eq 'pdf') {
            my $foo = $response->content;
            my $filename = '/tmp/test.pdf';
            open(OUTFILE, ">", $filename) || print STDERR qq{Cannot open $filename for writing\n};
            print OUTFILE $foo;
            close( OUTFILE );
        }
    
        exit 0;
    }
    # POSSIBLY NOTREACHED

    if ($response->is_success) {
        print CGI::header(join(';', $response->content_type()));
        _print_encoded_output($Q, $response);
    }
    else {
        my $code = $response->code;
        my $status = $response->status_line . " " . (($code !~ m,^5\d\d,) ? $response->content : '');

        Call_Handler(0, 'Data API error: ' . $status);
    }

    exit 0;
}

# ---------------------------------------------------------------------

=item _get_config

Description

=cut

# ---------------------------------------------------------------------
sub _get_config {
    my $ver = 1;
    my $config = new API::HTD::HConf(
                                     [
                                      $ENV{SDRROOT} . '/htd/lib/API/HTD/base-config.yaml',
                                      $ENV{SDRROOT} . qq{/htd/lib/API/HTD/App/V_${ver}/config.yaml},
                                     ]
                                    );
    return ($config->initSuccess ? $config : 0);
}

# ---------------------------------------------------------------------

=item _htdc_connect

Description

=cut

# ---------------------------------------------------------------------
sub _htdc_connect {
    my $config = shift;

    return
      API::DbIF::databaseConnect
          (
           $config->getConfigVal('database', 'name'),
           $config->getConfigVal('database', 'user'),
           $config->getConfigVal('database', 'passwd'),
           $config->getConfigVal('database', 'server'),
          );
}

# ---------------------------------------------------------------------

=item _get_consumer

Description

=cut

# ---------------------------------------------------------------------
sub _get_consumer {
    my $dbh = shift;
    my $access_key = shift;

    my $secret_key = API::HTD::AuthDb::get_secret_by_active_access_key($dbh, $access_key);
    my $consumer = OAuth::Lite::Consumer->new
      (
       consumer_key    => $access_key,
       consumer_secret => $secret_key,
       auth_method     => OAuth::Lite::AuthMethod::URL_QUERY,
      );

    return $consumer;
}

# ---------------------------------------------------------------------

=item _make_Data_API_request_url

Due to the network architecture that includes the net scaler, to do
secure transport over SSL we use http:// over port 443, NOT https://
but only for production.  This also means that test.babel will fail
SSL negotiation if SSL is involved.

=cut

# ---------------------------------------------------------------------
sub _make_Data_API_request_url {
    my $Q = shift;

    my $port = '';
    my $protocol = 'http://';

    if ($ENV{HT_DEV}) {
        $protocol = 'https://';
    }
    else {
        $port = ':443';
    }

    my ($id, $resource, $seq) = ($Q->param('id'), $Q->param('resource'), $Q->param('seq'));
    my $url = $protocol . $ENV{HTTP_HOST} . $port . '/cgi/htd' . qq{/$resource} . qq{/$id} . ($seq ? qq{/$seq} : '');

    # so API can do geo ip lookup for this user
    my $client_IPADDR = IPADDR_of_my_client();
    my $extra = { ip => $client_IPADDR };

    if ($DEVELOPMENT_SUPPORT) {
        if ($resource eq 'pdf') {
            $extra->{format} = 'ebm';
        }
        elsif ($resource eq 'pageimage') {
            my $format = $Q->param('format');
            if ($format ne 'raw') {
                $extra->{format} = $Q->param('format');
                if ($Q->param('unwatermark') eq 'on') {
                    $extra->{watermark} = 0;
                }

                $extra->{res} = $Q->param('res') || 0;
            }
        }
    }

    return ($url, $extra);
}

# ---------------------------------------------------------------------

=item _standard_replacements

Description

=cut

# ---------------------------------------------------------------------
sub _standard_replacements {
    my $page_ref = shift;

    my $header_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/header.chunk');
    $$page_ref =~ s,___HEADER_CHUNK___,$$header_ref,;

    my $analytics_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/google_analytics.chunk');
    $$page_ref =~ s,___GOOGLE_ANALYTICS___,$$analytics_ref,;

    my $empty = '';
    my $extended_types_ref = $DEVELOPMENT_SUPPORT ? Utils::read_file($ENV{SDRROOT} . '/htdc/web/extended_types.chunk') : \$empty;
    $$page_ref =~ s,___EXTENDED_TYPES___,$$extended_types_ref,;

    my $extended_opts_ref = $DEVELOPMENT_SUPPORT ? Utils::read_file($ENV{SDRROOT} . '/htdc/web/extended_options.chunk') : \$empty;
    $$page_ref =~ s,___EXTENDED_OPTIONS___,$$extended_opts_ref,;

    my $extended_opts_js_ref = $DEVELOPMENT_SUPPORT ? Utils::read_file($ENV{SDRROOT} . '/htdc/web/extended_options_js.chunk') : \$empty;
    $$page_ref =~ s,___EXTENDED_OPTIONS_JS___,$$extended_opts_js_ref,;
}
