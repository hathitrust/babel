#!/usr/bin/env perl

=head1 NAME

htdc

=head1 DESCRIPTION

This is a perl 2-legged oauth client that uses their auth credentials
as a proxy for the oauth keys and constructs a signed Data API
request.

=head1 SYNOPSIS

For example:

http://babel.hathitrust.org/cgi/htdc (present the data entry form)

http://babel.hathitrust.org/cgi/htdc?resource=pagemeta&id=mdp.39015063764644&seq=5 (send a request to Data API)

=head1 OUTPUT

The form or the resource

=cut

use strict;
use warnings;

umask 0000;

use lib "$ENV{SDRROOT}/mdp-lib/Utils";
use Vendors;

use CGI;
use URI;
use YAML::Any;
use Encode;

use HTTP::Request;
use LWP::UserAgent;

use Context;
use Utils;
use Debug::DUtils;

use API::DbIF;
use API::HTD_Log;

use API::HTD::AuthDb;
use API::HTD::HConf;
use HOAuth::Signature;

BEGIN {
    ## $ENV{DEBUG_LOCAL} = 1;
    # non-US testing
    ## $ENV{REMOTE_ADDR} = '147.96.1.135'; # non-US
}

my $Q = new CGI;

# forced upstream
my $USERID = $ENV{REMOTE_USER};

my $PRODDUCTION_MODE = 0;

my @superusers = qw(pfarber roger rrotter);
my $DEVELOPMENT_SUPPORT = 0;

if ($PRODDUCTION_MODE) {      
    delete $ENV{HT_DEV};
}
else {
    $DEVELOPMENT_SUPPORT = defined($ENV{HT_DEV}) || grep(/^$USERID$/, @superusers);
}

my $DEBUG = 0;
if ($DEVELOPMENT_SUPPORT) {
    $DEBUG = $Q->param('debug') || $DEBUG;
}

if (! defined $ENV{REMOTE_USER}) {
    serve_login_page();
}
elsif (! $Q->param) {
    serve_request_form_page();
    # NOTREACHED
}
else {
    my $config = Call_Handler(_get_config(), 'System configuration error');
    # POSSIBLY NOTREACHED

    my $dbh = Call_Handler(_htdc_connect($config), 'Database error');
    # POSSIBLY NOTREACHED

    my $access_key = validate_request($Q, $dbh, $config);
    # POSSIBLY NOTREACHED

    if ($DEBUG == 2) {
        serve_DEBUG_Data_API_uri($Q, $dbh, $access_key);
    }
    elsif ($DEBUG == 1) {
        serve_DEBUG_Data_API_response($Q, $dbh, $config, $access_key);
    }
    else {
        serve_Data_API_response($Q, $dbh, $config, $access_key);
    }
    # NOTREACHED
}

exit 0;


# ---------------------------------------------------------------------

=item Call_Handler

Description

=cut

# ---------------------------------------------------------------------
sub Call_Handler {
    my $return_from_call = shift;
    my $in_case_of_error = shift;

    if (! $return_from_call) {
        serve_error_page($in_case_of_error);
    }

    return $return_from_call;
}

# ---------------------------------------------------------------------

=item validate_request

Description

=cut

# ---------------------------------------------------------------------
sub validate_request {
    my ($Q, $dbh, $config) = @_;

    # known?
    my $access_key = Call_Handler(API::HTD::AuthDb::get_access_key_by_userid($dbh, $USERID),
                                  qq{Your user ID is not registered. Please visit the <a href="/cgi/kgs/authed">registration page</a> to record your user id});

    Utils::clean_cgi_params($Q);

    # all params present?
    Call_Handler($Q->param('id'), 'Please specify an ID');

    my $resource = $Q->param('resource');
    Call_Handler($resource, 'Please specify a resource');

    if (grep(/^$resource$/, qw( pagemeta pageimage pageocr pagecoordocr ))) {
        my $seq = $Q->param('seq');
        if (! $seq) {
            Call_Handler(0, 'Please specify a sequence number');
        }
        elsif ($seq !~ m,^\d+$,) {
            Call_Handler(0, 'Please specify a sequence number that consists of only digits');
        }
    }
    else {
        $Q->Delete('seq');
    }

    unless ($DEVELOPMENT_SUPPORT) {
        # No debug support and only resolution and width for sizing
        # when in production
        foreach my $arg ( qw(debug size height) ) {
            $Q->Delete($arg);
        }
    }

    return $access_key;
}

# ---------------------------------------------------------------------

=item serve_login_page

Description

=cut

# ---------------------------------------------------------------------
sub serve_login_page {
    hLOG(qq{htdc: serve login page});

    my $page_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/htdc_login.html');

    my $wayf_link = _get_htdc_wayf_link();
    $$page_ref =~ s,___WAYF_LINK___,$wayf_link,;

    _standard_replacements($page_ref);

    print CGI::header('text/html');
    print $$page_ref;
    exit 0;
}


# ---------------------------------------------------------------------

=item serve_error_page

Description

=cut

# ---------------------------------------------------------------------
sub serve_error_page {
    my $error_message = shift;

    hLOG(qq{htdc ERROR: serve error page: $error_message});

    my $page_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/htdc_error.html');
    $$page_ref =~ s,___FAIL_REASON___,$error_message,;

    _standard_replacements($page_ref);

    print CGI::header('text/html');
    print $$page_ref;
    exit 0;
}

# ---------------------------------------------------------------------

=item serve_request_form_page

Description

=cut

# ---------------------------------------------------------------------
sub serve_request_form_page {
    hLOG(qq{htdc: serve request form});

    my $page_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/htdc_request_form.html');
    _standard_replacements($page_ref);

    print CGI::header('text/html');
    print $$page_ref;
    exit 0;
}


# ---------------------------------------------------------------------

=item _get_htdc_wayf_link

Description

=cut

# ---------------------------------------------------------------------
sub _get_htdc_wayf_link {
    my $C = shift;

    my $target = 'https://' . $ENV{HTTP_HOST} . '/cgi/kgs/authed';
    # wayf will change target /cgi into /shcgi, depending
    my $url = 'http://' . $ENV{HTTP_HOST} . '/cgi/wayf' . '?target=' . CGI::escape($target);

    return $url;
}

# ---------------------------------------------------------------------

=item _print_encoded_output

Description

=cut

# ---------------------------------------------------------------------
sub _print_encoded_output {
    my ($Q, $response) = @_;

    my $resource = $Q->param('resource');
    if (grep(/^$resource$/, qw(aggregate pageimage pdf))) {
        # Do not encode binary types
        print $response->content;
    }
    else {
        print Encode::encode_utf8(Encode::decode_utf8($response->content));
    }
}

# ---------------------------------------------------------------------

=item IPADDR_of_my_client

Description

=cut

# ---------------------------------------------------------------------
sub IPADDR_of_my_client {
    return $ENV{HTTP_X_FORWARDED_FOR} || $ENV{REMOTE_ADDR};
}

# ---------------------------------------------------------------------

=item serve_DEBUG_Data_API_uri

Description

=cut

# ---------------------------------------------------------------------
sub serve_DEBUG_Data_API_uri {
    my ($Q, $dbh, $access_key) = @_;

    my $signed_url = _make_Data_API_request_url($Q, $dbh, $access_key);

    print CGI::header('text/html');
    print "<p><b>[CLIENT] URL to paste to server:</b><br/>";
    print $signed_url;

    exit 0;
}

# ---------------------------------------------------------------------

=item serve_DEBUG_Data_API_response

Description

=cut

# ---------------------------------------------------------------------
sub serve_DEBUG_Data_API_response {
    my ($Q, $dbh, $config, $access_key) = @_;

    my $signed_url = _make_Data_API_request_url($Q, $dbh, $access_key);
    my $response = _get_response($signed_url);

    # Debug block
    print CGI::header('text/html');
    print "<p><b>[CLIENT] sent this URL to server:</b><br/>";
    print $signed_url;

    print "<p><b>[CLIENT] received this HTTP response from server:</b><br/>";
    print "<b>Status:</b> " . $response->status_line;
    print "<br/>";
    print "<b>Header:</b> " . $response->headers->as_string;
    print "<br/>";
    print "<b>Content:</b> " . $response->content;

    if ($Q->param('resource') eq 'pdf') {
        my $foo = $response->content;
        my $filename = '/tmp/test.pdf';
        open(OUTFILE, ">", $filename) || print STDERR qq{Cannot open $filename for writing\n};
        print OUTFILE $foo;
        close( OUTFILE );
    }

    exit 0;
}


# ---------------------------------------------------------------------

=item serve_Data_API_response

Description

=cut

# ---------------------------------------------------------------------
sub serve_Data_API_response {
    my ($Q, $dbh, $config, $access_key) = @_;

    my $signed_url = _make_Data_API_request_url($Q, $dbh, $access_key);
    my $response = _get_response($signed_url);
    hLOG(qq{htdc: serve_Data_API_response: signed request url=$signed_url});

    if ($response->is_success) {
        print CGI::header(join(';', $response->content_type()));
        _print_encoded_output($Q, $response);
    }
    else {
        my $code = $response->code;
        my $status = $response->status_line . " " . (($code !~ m,^5\d\d,) ? $response->content : '');

        Call_Handler(0, 'Data API error: ' . $status);
    }

    exit 0;
}

# ---------------------------------------------------------------------

=item _get_config

Description

=cut

# ---------------------------------------------------------------------
sub _get_config {
    my $ver = 1;
    my $config = new API::HTD::HConf(
                                     [
                                      $ENV{SDRROOT} . '/htd/lib/API/HTD/base-config.yaml',
                                      $ENV{SDRROOT} . qq{/htd/lib/API/HTD/App/V_${ver}/config.yaml},
                                     ]
                                    );
    return ($config->initSuccess ? $config : 0);
}

# ---------------------------------------------------------------------

=item _htdc_connect

Description

=cut

# ---------------------------------------------------------------------
sub _htdc_connect {
    my $config = shift;

    return
      API::DbIF::databaseConnect
          (
           $config->getConfigVal('database', 'name'),
           $config->getConfigVal('database', 'user'),
           $config->getConfigVal('database', 'passwd'),
           $config->getConfigVal('database', 'server'),
          );
}

# ---------------------------------------------------------------------

=item _get_user_agent

Description

=cut

# ---------------------------------------------------------------------
sub _get_user_agent {

    my $ua = LWP::UserAgent->new;
    $ua->agent("HathiTrust Data API Client");

    return $ua;
}

# ---------------------------------------------------------------------

=item _get_response

Due to the production network architecture that includes the net
scaler, to do transport over SSL in production use http:// over port
443, NOT https://.  This also means that test.babel will fail SSL
negotiation if SSL is involved.

This is only a problem for this client because it is behind the net
scaler on the same server as the Data API itself.

When Data API sees SERVER_PORT == 443, it assumes a URL string that
begins with 'https://' in signature_safe_url().

=cut

# ---------------------------------------------------------------------
sub _get_response {
    my $url = shift;
    
    # Assuming a signed URL string of 'https://host/pathinfo?query'
    # but sending it as 'http://host:443/pathinfo?query' when in production.
    #
    $url =~ s,(^https:)//(.*?)/(.*$),http://$2:443/$3, unless ($ENV{HT_DEV});

    my $req = HTTP::Request->new(     
                                 GET => "$url"
                                );
    my $ua =  _get_user_agent();
    my $res = $ua->request($req);

    return $res;
}

# ---------------------------------------------------------------------

=item _make_Data_API_request_url

For simplicity, htdc always sends its request over SSL even for PD
data.

=cut

# ---------------------------------------------------------------------
sub _make_Data_API_request_url {
    my $Q = shift;
    my $dbh = shift;
    my $access_key = shift;

    my $protocol = 'https://';

    if ($ENV{HT_DEV}) {
        if (! Debug::DUtils::under_server) {
            $ENV{HTTP_HOST} = $ENV{REMOTE_USER} . '-full.babel.hathitrust.org';
        }
    }

    my ($id, $resource, $seq) = ($Q->param('id'), $Q->param('resource'), $Q->param('seq'));
    # So API can do geo ip lookup for this user
    my $client_IPADDR = IPADDR_of_my_client(); 
    my $extra = { ip => $client_IPADDR };

    if ($DEVELOPMENT_SUPPORT) {
        if ($resource eq 'pdf') {
            $extra->{format} = 'ebm';
        }
    }

    if ($resource eq 'pageimage') {
        my $format = $Q->param('format');
        $extra->{format} = $format;
        if ($format ne 'raw') {
            if ($Q->param('unwatermark') eq 'on') {
                $extra->{watermark} = 0;
            }
            my $res = $Q->param('res');
            my $width = $Q->param('width');

            # Prefer resolution
            if (defined $res) {
                $extra->{res} = $res || 0;
            }
            elsif (defined $width) {
                $extra->{width} = $width || 680;
            }
            else {
                $extra->{res} = $res || 0;
            }
        }
    }

    my $url = $protocol . $ENV{HTTP_HOST} . '/cgi/htd' . qq{/$resource} . qq{/$id} . ($seq ? qq{/$seq} : '');


    my $secret_key = API::HTD::AuthDb::get_secret_by_active_access_key($dbh, $access_key);
    my $signed_url = HOAuth::Signature::S_get_signed_request_URL($url, $access_key, $secret_key, 'GET', $extra);

    return $signed_url;
}

# ---------------------------------------------------------------------

=item _standard_replacements

Description

=cut

# ---------------------------------------------------------------------
sub _standard_replacements {
    my $page_ref = shift;

    my $header_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/header.chunk');
    $$page_ref =~ s,___HEADER_CHUNK___,$$header_ref,;

    my $analytics_ref = Utils::read_file($ENV{SDRROOT} . '/htdc/web/google_analytics.chunk');
    $$page_ref =~ s,___GOOGLE_ANALYTICS___,$$analytics_ref,;

    my $empty = '';
    my $extended_types_ref = $DEVELOPMENT_SUPPORT ? Utils::read_file($ENV{SDRROOT} . '/htdc/web/extended_types.chunk') : \$empty;
    $$page_ref =~ s,___EXTENDED_TYPES___,$$extended_types_ref,;

    my $extended_opts_ref = $DEVELOPMENT_SUPPORT ? Utils::read_file($ENV{SDRROOT} . '/htdc/web/extended_options.chunk') : \$empty;
    $$page_ref =~ s,___EXTENDED_OPTIONS___,$$extended_opts_ref,;

    my $extended_opts_js_ref = $DEVELOPMENT_SUPPORT ? Utils::read_file($ENV{SDRROOT} . '/htdc/web/extended_options_js.chunk') : \$empty;
    $$page_ref =~ s,___EXTENDED_OPTIONS_JS___,$$extended_opts_js_ref,;
}
